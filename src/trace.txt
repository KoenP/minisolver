[1 of 1] Compiling Main             ( GHCTest.hs, GHCTest.o )
checkFamInstConsistency [Prelude]
Tc2 (src)
Tc3
tcExtendKindEnvList []
tcExtendKindEnvList []
---- tcTyClGroup ---- {
Decls for [F]
tcExtendKindEnv [rrX :-> APromotionErr TyConPE]
---- kcTyClGroup ---- {
  module Main
  type family F a_as3
solveLocalEqualities {
env2 [(a_as3, Type variable ‘a_as3’ = a_as3[sk:0] :: *)]
tcExtendBinderStack [a_as3 a_as3[sk:0]]
checkConstraints
  1
  [a_as3[sk:0]]
solveLocalEqualities: running solver { WC {}
newNoTcEvBinds unique = a114
solveWanteds { WC {}
solveSimpleWanteds { {}
solveSimpleWanteds end }
  iterations = 1
  residual = WC {}
solveWanteds }
  final wc = WC {}
  current evbinds  = {}
unflattenGivens []
solveLocalEqualities: running solver } WC {}
solveLocalEqualities end }
solveEqualities { wanted =  WC {}
newNoTcEvBinds unique = a115
solveWanteds { WC {}
solveSimpleWanteds { {}
solveSimpleWanteds end }
  iterations = 1
  residual = WC {}
solveWanteds }
  final wc = WC {}
  current evbinds  = {}
unflattenGivens []
End solveEqualities }
reportAllUnsolved {
newNoTcEvBinds unique = a116
reportAllUnsolved }
quantifyTyVars
  DV {dv_kvs = [] dv_tvs = []}
  []
quantifyTyVars
  globals: []
  nondep:
  dep:
  dep_kvs'
  nondep_tvs'
kcLHsQTyVars: cusk
  F
  []
  [a_as3]
  []
  [a_as3[sk:0]]
  * -> *
  []
  [anon (a_as3[sk:0])]
kcTyClGroup: initial kinds F :: * -> *
tcExtendKindEnvList [(F, ATcTyCon F[tc] :: * -> *)]
kcTyClDecl skipped due to cusk F
solveEqualities { wanted =  WC {}
newNoTcEvBinds unique = a117
solveWanteds { WC {}
solveSimpleWanteds { {}
solveSimpleWanteds end }
  iterations = 1
  residual = WC {}
solveWanteds }
  final wc = WC {}
  current evbinds  = {}
unflattenGivens []
End solveEqualities }
reportAllUnsolved {
newNoTcEvBinds unique = a118
reportAllUnsolved }
quantifyTyVars
  DV {dv_kvs = [] dv_tvs = []}
  []
quantifyTyVars
  globals: []
  nondep:
  dep:
  dep_kvs'
  nondep_tvs'
Generalise kind
  F
  [anon (a_as3[sk:0])]
  * -> *
  []
  [anon (a_as3[sk:0])]
  *
  [anon (a_as3)]
  *
  [(a_as3, a_as3[sk:0])]
---- kcTyClGroup end ---- } F :: * -> *
tcTyAndCl generalized kinds (F, [anon (a_as3)], * True)
tcExtendKindEnvList [(F, ATcTyCon F[tc] :: * -> *)]
---- tcTyClDecl ---- { type family F a_as3
tcTyClTyVars F [anon (a_as3)]
env2 [(a_as3, Type variable ‘a_as3’ = a_as3[sk:0] :: *)]
tcExtendBinderStack [a_as3 a_as3[sk:0]]
open type family: F
checkConstraints
  1
  [a_as3[sk:0]]
---- tcTyClDecl end ---- } F
Starting synonym cycle check [F]
Done synonym cycle check [F]
Starting validity check [F]
Starting validity for tycon F
checkValidTyCon
  F
  Nothing
Done validity for tycon F
Done validity check [F]
---- end tcTyClGroup ---- }
tcAddTyCons
  tycons [F]
  implicits []
tcExtendKindEnvList []
env2 []
tcFamInstDecl F
solveLocalEqualities {
tcInferApps {
  F
  [[Int]]
  * -> *
tcInferApps (vis)
  [anon] *
  [Int]
  *
  [TCvSubst In scope: InScope {} Type env: [] Co env: []]
lk1 Int
tcTyVar2a
  Int
  *
checkExpectedKind
  Int
  act_kind: *
  act_kind': *
  exp_kind: *
checkExpectedKind
  [Int]
  act_kind: *
  act_kind': *
  exp_kind: *
tcInferApps (vis 1) *
tcInferApps }
kcTyFamEqnRhs
  rhs_hs_ty = Int
  lhs_ki = *
  insted_lhs_ki = *
  new_pats = []
lk1 Int
tcTyVar2a
  Int
  *
checkExpectedKind
  Int
  act_kind: *
  act_kind': *
  exp_kind: *
solveLocalEqualities: running solver { WC {}
newNoTcEvBinds unique = a119
solveWanteds { WC {}
solveSimpleWanteds { {}
solveSimpleWanteds end }
  iterations = 1
  residual = WC {}
solveWanteds }
  final wc = WC {}
  current evbinds  = {}
unflattenGivens []
solveLocalEqualities: running solver } WC {}
solveLocalEqualities end }
solveEqualities { wanted =  WC {}
newNoTcEvBinds unique = a11a
solveWanteds { WC {}
solveSimpleWanteds { {}
solveSimpleWanteds end }
  iterations = 1
  residual = WC {}
solveWanteds }
  final wc = WC {}
  current evbinds  = {}
unflattenGivens []
End solveEqualities }
reportAllUnsolved {
newNoTcEvBinds unique = a11b
reportAllUnsolved }
quantifyTyVars
  DV {dv_kvs = [] dv_tvs = []}
  []
quantifyTyVars
  globals: []
  nondep:
  dep:
  dep_kvs'
  nondep_tvs'
tcFamTyPats
  F
  [[(Int |> <*>_N)]]
  []
env2 []
tcExtendBinderStack []
lk1 Int
tcTyVar2a
  Int
  *
checkExpectedKind
  Int
  act_kind: *
  act_kind': *
  exp_kind: *
solveEqualities { wanted =  WC {}
newNoTcEvBinds unique = a11c
solveWanteds { WC {}
solveSimpleWanteds { {}
solveSimpleWanteds end }
  iterations = 1
  residual = WC {}
solveWanteds }
  final wc = WC {}
  current evbinds  = {}
unflattenGivens []
End solveEqualities }
reportAllUnsolved {
newNoTcEvBinds unique = a11d
reportAllUnsolved }
tcTyFamInstEqn F
checkVTFE
  F [Int]
  Int
  []
Adding instances:
addLocalFamInst type instance F [Int]
alfi Main
checkForConflicts
  []
  type instance F [Int]
addFamInsts type instance F [Int]
tcAddTyCons
  tycons []
  implicits []
tcExtendKindEnvList []
env2 []
---- tcTyClGroup ---- {
Decls for [G]
tcExtendKindEnv [rpY :-> APromotionErr TyConPE]
---- kcTyClGroup ---- {
  module Main
  type family G a_as2
solveLocalEqualities {
env2 [(a_as2, Type variable ‘a_as2’ = a_as2[sk:0] :: *)]
tcExtendBinderStack [a_as2 a_as2[sk:0]]
checkConstraints
  1
  [a_as2[sk:0]]
solveLocalEqualities: running solver { WC {}
newNoTcEvBinds unique = a11f
solveWanteds { WC {}
solveSimpleWanteds { {}
solveSimpleWanteds end }
  iterations = 1
  residual = WC {}
solveWanteds }
  final wc = WC {}
  current evbinds  = {}
unflattenGivens []
solveLocalEqualities: running solver } WC {}
solveLocalEqualities end }
solveEqualities { wanted =  WC {}
newNoTcEvBinds unique = a11g
solveWanteds { WC {}
solveSimpleWanteds { {}
solveSimpleWanteds end }
  iterations = 1
  residual = WC {}
solveWanteds }
  final wc = WC {}
  current evbinds  = {}
unflattenGivens []
End solveEqualities }
reportAllUnsolved {
newNoTcEvBinds unique = a11h
reportAllUnsolved }
quantifyTyVars
  DV {dv_kvs = [] dv_tvs = []}
  []
quantifyTyVars
  globals: []
  nondep:
  dep:
  dep_kvs'
  nondep_tvs'
kcLHsQTyVars: cusk
  G
  []
  [a_as2]
  []
  [a_as2[sk:0]]
  * -> *
  []
  [anon (a_as2[sk:0])]
kcTyClGroup: initial kinds G :: * -> *
tcExtendKindEnvList [(G, ATcTyCon G[tc] :: * -> *)]
kcTyClDecl skipped due to cusk G
solveEqualities { wanted =  WC {}
newNoTcEvBinds unique = a11i
solveWanteds { WC {}
solveSimpleWanteds { {}
solveSimpleWanteds end }
  iterations = 1
  residual = WC {}
solveWanteds }
  final wc = WC {}
  current evbinds  = {}
unflattenGivens []
End solveEqualities }
reportAllUnsolved {
newNoTcEvBinds unique = a11j
reportAllUnsolved }
quantifyTyVars
  DV {dv_kvs = [] dv_tvs = []}
  []
quantifyTyVars
  globals: []
  nondep:
  dep:
  dep_kvs'
  nondep_tvs'
Generalise kind
  G
  [anon (a_as2[sk:0])]
  * -> *
  []
  [anon (a_as2[sk:0])]
  *
  [anon (a_as2)]
  *
  [(a_as2, a_as2[sk:0])]
---- kcTyClGroup end ---- } G :: * -> *
tcTyAndCl generalized kinds (G, [anon (a_as2)], * True)
tcExtendKindEnvList [(G, ATcTyCon G[tc] :: * -> *)]
---- tcTyClDecl ---- { type family G a_as2
tcTyClTyVars G [anon (a_as2)]
env2 [(a_as2, Type variable ‘a_as2’ = a_as2[sk:0] :: *)]
tcExtendBinderStack [a_as2 a_as2[sk:0]]
open type family: G
checkConstraints
  1
  [a_as2[sk:0]]
---- tcTyClDecl end ---- } G
Starting synonym cycle check [G]
Done synonym cycle check [G]
Starting validity check [G]
Starting validity for tycon G
checkValidTyCon
  G
  Nothing
Done validity for tycon G
Done validity check [G]
---- end tcTyClGroup ---- }
tcAddTyCons
  tycons [G]
  implicits []
tcExtendKindEnvList []
env2 []
tcFamInstDecl G
solveLocalEqualities {
newMetaKindVar k_a11k[tau:1]
env2
  [(a_as4, Type variable ‘a_as4’ = a_as4[sk:1] :: k_a11k[tau:1])]
tcExtendBinderStack [a_as4 a_as4[sk:1]]
tcInferApps {
  G
  [[a_as4]]
  * -> *
tcInferApps (vis)
  [anon] *
  [a_as4]
  *
  [TCvSubst In scope: InScope {} Type env: [] Co env: []]
lk1 a_as4
checkExpectedKind
  a_as4
  act_kind: k_a11k[tau:1]
  act_kind': k_a11k[tau:1]
  exp_kind: *
u_tys
  tclvl 1
  k_a11k[tau:1] ~ *
  arising from a type equality k_a11k[tau:1] ~ *
u_tys
  tclvl 1
  * ~ *
  arising from a kind equality arising from k_a11k[tau:1] ~ *
u_tys
  tclvl 1
  'GHC.Types.LiftedRep ~ 'GHC.Types.LiftedRep
  arising from a kind equality arising from k_a11k[tau:1] ~ *
u_tys yields no coercion
u_tys yields no coercion
writeMetaTyVar k_a11k[tau:1] :: * := *
u_tys yields no coercion
checkExpectedKind
  k_a11k[tau:1]
  *
  <*>_N
checkExpectedKind
  [a_as4]
  act_kind: *
  act_kind': *
  exp_kind: *
tcInferApps (vis 1) *
tcInferApps }
kcTyFamEqnRhs
  rhs_hs_ty = Bool
  lhs_ki = *
  insted_lhs_ki = *
  new_pats = []
lk1 Bool
tcTyVar2a
  Bool
  *
checkExpectedKind
  Bool
  act_kind: *
  act_kind': *
  exp_kind: *
solveLocalEqualities: running solver { WC {}
newNoTcEvBinds unique = a11l
solveWanteds { WC {}
solveSimpleWanteds { {}
solveSimpleWanteds end }
  iterations = 1
  residual = WC {}
solveWanteds }
  final wc = WC {}
  current evbinds  = {}
unflattenGivens []
solveLocalEqualities: running solver } WC {}
solveLocalEqualities end }
tcImplicitTKBndrs
  [a_as4]
  [a_as4[sk:1]]
solveEqualities { wanted =  WC {}
newNoTcEvBinds unique = a11m
solveWanteds { WC {}
solveSimpleWanteds { {}
solveSimpleWanteds end }
  iterations = 1
  residual = WC {}
solveWanteds }
  final wc = WC {}
  current evbinds  = {}
unflattenGivens []
End solveEqualities }
reportAllUnsolved {
newNoTcEvBinds unique = a11n
reportAllUnsolved }
quantifyTyVars
  DV {dv_kvs = [] dv_tvs = [as4 :-> a_as4[sk:1]]}
  []
quantifyTyVars
  globals: []
  nondep: a_as4[sk:1]
  dep:
  dep_kvs'
  nondep_tvs' a_as4[sk:1]
tcFamTyPats
  G
  [[(a_as4[sk:1] |> <*>_N)]]
  [a_as4[sk:1]]
env2 [(a_as4, Type variable ‘a_as4’ = a_as4[sk:1] :: *)]
tcExtendBinderStack [a_as4 a_as4[sk:1]]
lk1 Bool
tcTyVar2a
  Bool
  *
checkExpectedKind
  Bool
  act_kind: *
  act_kind': *
  exp_kind: *
solveEqualities { wanted =  WC {}
newNoTcEvBinds unique = a11o
solveWanteds { WC {}
solveSimpleWanteds { {}
solveSimpleWanteds end }
  iterations = 1
  residual = WC {}
solveWanteds }
  final wc = WC {}
  current evbinds  = {}
unflattenGivens []
End solveEqualities }
reportAllUnsolved {
newNoTcEvBinds unique = a11p
reportAllUnsolved }
tcTyFamInstEqn G a_as4
checkConstraints
  1
  [a_as4[sk:1]]
checkVTFE
  G [a_as4]
  Bool
  []
Adding instances:
addLocalFamInst type instance G [a]
alfi Main
checkForConflicts
  []
  type instance G [a]
addFamInsts type instance G [a]
tcAddTyCons
  tycons []
  implicits []
tcExtendKindEnvList []
env2 []
tcDeriving False
tcDeriving 1 []
rnd
Adding instances:
Tc3b
Tc3c
tcSemigroupWarnings
Tc4
Tc4a
Tc5
tcExtendKindEnvList []
tcHsSigType { forall a_aVM. (a_aVM ~ [F a_aVM]) => a_aVM -> Bool
newAnonMetaTyVar t_a11s[tau:0]
decideKindGeneralisationPlan
  forall a_aVM. (a_aVM ~ [F a_aVM]) => a_aVM -> Bool
  should gen? True
solveLocalEqualities {
newMetaKindVar k_a11t[tau:1]
env2
  [(a_aVM, Type variable ‘a_aVM’ = a_aVM[sk:1] :: k_a11t[tau:1])]
tcExtendBinderStack [a_aVM a_aVM[sk:1]]
lk1 ~
tcTyVar2a
  ~
  forall k. k -> k -> Constraint
tcInferApps {
  (~)
  [a_aVM, [F a_aVM]]
  forall k. k -> k -> Constraint
tcInferApps (invis)
  @k_a11u
  [TCvSubst In scope: InScope {} Type env: [] Co env: []]
cloneAnonMetaTyVar k_a11A[tau:1]
tcInferApps (vis)
  [anon] k_a11u
  a_aVM
  k_a11u
  [TCvSubst
     In scope: InScope {k_a11A}
     Type env: [a11u :-> k_a11A[tau:1]]
     Co env: []]
lk1 a_aVM
checkExpectedKind
  a_aVM
  act_kind: k_a11t[tau:1]
  act_kind': k_a11t[tau:1]
  exp_kind: k_a11A[tau:1]
u_tys
  tclvl 1
  k_a11t[tau:1] ~ k_a11A[tau:1]
  arising from a type equality k_a11t[tau:1] ~ k_a11A[tau:1]
u_tys
  tclvl 1
  * ~ *
  arising from a kind equality arising from
    k_a11t[tau:1] ~ k_a11A[tau:1]
u_tys
  tclvl 1
  'GHC.Types.LiftedRep ~ 'GHC.Types.LiftedRep
  arising from a kind equality arising from
    k_a11t[tau:1] ~ k_a11A[tau:1]
u_tys yields no coercion
u_tys yields no coercion
writeMetaTyVar k_a11t[tau:1] :: * := k_a11A[tau:1]
u_tys yields no coercion
checkExpectedKind
  k_a11t[tau:1]
  k_a11A[tau:1]
  <k_a11A[tau:1]>_N
tcInferApps (vis 1) k_a11A[tau:1]
tcInferApps (vis)
  [anon] k_a11u
  [F a_aVM]
  k_a11u
  [TCvSubst
     In scope: InScope {k_a11A}
     Type env: [a11u :-> k_a11A[tau:1]]
     Co env: []]
lk1 F
instantiating tybinders:
instantiateTyN
  * -> *
  1
  [TCvSubst In scope: InScope {} Type env: [] Co env: []]
  * -> *
  * -> *
tcTyVar2b
  F :: * -> *
  * -> *
tcInferApps {
  F
  [a_aVM]
  * -> *
tcInferApps (vis)
  [anon] *
  a_aVM
  *
  [TCvSubst In scope: InScope {} Type env: [] Co env: []]
lk1 a_aVM
checkExpectedKind
  a_aVM
  act_kind: k_a11A[tau:1]
  act_kind': k_a11A[tau:1]
  exp_kind: *
u_tys
  tclvl 1
  k_a11A[tau:1] ~ *
  arising from a type equality k_a11A[tau:1] ~ *
u_tys
  tclvl 1
  * ~ *
  arising from a kind equality arising from k_a11A[tau:1] ~ *
u_tys
  tclvl 1
  'GHC.Types.LiftedRep ~ 'GHC.Types.LiftedRep
  arising from a kind equality arising from k_a11A[tau:1] ~ *
u_tys yields no coercion
u_tys yields no coercion
writeMetaTyVar k_a11A[tau:1] :: * := *
u_tys yields no coercion
checkExpectedKind
  k_a11A[tau:1]
  *
  <*>_N
tcInferApps (vis 1) *
tcInferApps }
checkExpectedKind
  F a_aVM
  act_kind: *
  act_kind': *
  exp_kind: *
checkExpectedKind
  [F a_aVM]
  act_kind: *
  act_kind': *
  exp_kind: k_a11A[tau:1]
u_tys
  tclvl 1
  * ~ k_a11A[tau:1]
  arising from a type equality * ~ k_a11A[tau:1]
found filled tyvar k_a11A[tau:1] :-> *
u_tys
  tclvl 1
  'GHC.Types.LiftedRep ~ 'GHC.Types.LiftedRep
  arising from a type equality * ~ k_a11A[tau:1]
u_tys yields no coercion
u_tys yields no coercion
checkExpectedKind
  *
  k_a11A[tau:1]
  <*>_N
tcInferApps (vis 1) k_a11A[tau:1]
tcInferApps }
checkExpectedKind
  a_aVM ~ [F a_aVM]
  act_kind: Constraint
  act_kind': Constraint
  exp_kind: Constraint
newAnonMetaTyVar t_a11B[tau:1]
newAnonMetaTyVar t_a11C[tau:1]
newAnonMetaTyVar t_a11D[tau:1]
lk1 a_aVM
checkExpectedKind
  a_aVM
  act_kind: *
  act_kind': *
  exp_kind: TYPE t_a11C[tau:1]
u_tys
  tclvl 1
  * ~ TYPE t_a11C[tau:1]
  arising from a type equality * ~ TYPE t_a11C[tau:1]
u_tys
  tclvl 1
  'GHC.Types.LiftedRep ~ t_a11C[tau:1]
  arising from a type equality * ~ TYPE t_a11C[tau:1]
u_tys
  tclvl 1
  GHC.Types.RuntimeRep ~ GHC.Types.RuntimeRep
  arising from a kind equality arising from
    t_a11C[tau:1] ~ 'GHC.Types.LiftedRep
u_tys yields no coercion
writeMetaTyVar
  t_a11C[tau:1] :: GHC.Types.RuntimeRep := 'GHC.Types.LiftedRep
u_tys yields no coercion
u_tys yields no coercion
checkExpectedKind
  *
  TYPE t_a11C[tau:1]
  <*>_N
lk1 Bool
tcTyVar2a
  Bool
  *
checkExpectedKind
  Bool
  act_kind: *
  act_kind': *
  exp_kind: TYPE t_a11D[tau:1]
u_tys
  tclvl 1
  * ~ TYPE t_a11D[tau:1]
  arising from a type equality * ~ TYPE t_a11D[tau:1]
u_tys
  tclvl 1
  'GHC.Types.LiftedRep ~ t_a11D[tau:1]
  arising from a type equality * ~ TYPE t_a11D[tau:1]
u_tys
  tclvl 1
  GHC.Types.RuntimeRep ~ GHC.Types.RuntimeRep
  arising from a kind equality arising from
    t_a11D[tau:1] ~ 'GHC.Types.LiftedRep
u_tys yields no coercion
writeMetaTyVar
  t_a11D[tau:1] :: GHC.Types.RuntimeRep := 'GHC.Types.LiftedRep
u_tys yields no coercion
u_tys yields no coercion
checkExpectedKind
  *
  TYPE t_a11D[tau:1]
  <*>_N
checkExpectedKind
  a_aVM -> Bool
  act_kind: *
  act_kind': *
  exp_kind: TYPE t_a11B[tau:1]
u_tys
  tclvl 1
  * ~ TYPE t_a11B[tau:1]
  arising from a type equality * ~ TYPE t_a11B[tau:1]
u_tys
  tclvl 1
  'GHC.Types.LiftedRep ~ t_a11B[tau:1]
  arising from a type equality * ~ TYPE t_a11B[tau:1]
u_tys
  tclvl 1
  GHC.Types.RuntimeRep ~ GHC.Types.RuntimeRep
  arising from a kind equality arising from
    t_a11B[tau:1] ~ 'GHC.Types.LiftedRep
u_tys yields no coercion
writeMetaTyVar
  t_a11B[tau:1] :: GHC.Types.RuntimeRep := 'GHC.Types.LiftedRep
u_tys yields no coercion
u_tys yields no coercion
checkExpectedKind
  *
  TYPE t_a11B[tau:1]
  <*>_N
checkExpectedKind
  a_aVM -> Bool
  act_kind: *
  act_kind': *
  exp_kind: TYPE t_a11s[tau:0]
u_tys
  tclvl 1
  * ~ TYPE t_a11s[tau:0]
  arising from a type equality * ~ TYPE t_a11s[tau:0]
u_tys
  tclvl 1
  'GHC.Types.LiftedRep ~ t_a11s[tau:0]
  arising from a type equality * ~ TYPE t_a11s[tau:0]
New coercion hole: co_a11E
utype_defer
  'GHC.Types.LiftedRep
  t_a11s[tau:0]
  arising from a type equality * ~ TYPE t_a11s[tau:0]
  In the type signature:
    asdf :: forall a_aVM. (a_aVM ~ [F a_aVM]) => a_aVM -> Bool
utype_defer2 {co_a11E}
u_tys yields coercion: {co_a11E}
u_tys yields coercion: (TYPE {co_a11E})_N
checkExpectedKind
  *
  TYPE t_a11s[tau:0]
  (TYPE {co_a11E})_N
newNoTcEvBinds unique = a11F
tcExplicitTKBndrs
  Hs vars: [a_aVM]
  tvs: (a_aVM[sk:1] :: k_a11t[tau:1])
solveLocalEqualities: running solver {
  WC {wc_impl =
        Implic {
          TcLevel = 1
          Skolems = (a_aVM[sk:1] :: k_a11t[tau:1])
          No-eqs = True
          Status = Unsolved
          Given =
          Wanted =
            WC {wc_simple =
                  [WD] hole{co_a11E} {0}:: 'GHC.Types.LiftedRep
                                           GHC.Prim.~# t_a11s[tau:0] (CNonCanonical)}
          Binds = NoEvBindsVar<a11F>
          ‘forall a_aVM. (a_aVM ~ [F a_aVM]) => a_aVM -> Bool’ }}
newNoTcEvBinds unique = a11G
solveWanteds {
  WC {wc_impl =
        Implic {
          TcLevel = 1
          Skolems = (a_aVM[sk:1] :: k_a11t[tau:1])
          No-eqs = True
          Status = Unsolved
          Given =
          Wanted =
            WC {wc_simple =
                  [WD] hole{co_a11E} {0}:: 'GHC.Types.LiftedRep
                                           GHC.Prim.~# t_a11s[tau:0] (CNonCanonical)}
          Binds = NoEvBindsVar<a11F>
          ‘forall a_aVM. (a_aVM ~ [F a_aVM]) => a_aVM -> Bool’ }}
solveSimpleWanteds { {}
solveSimpleWanteds end }
  iterations = 1
  residual = WC {}
solveNestedImplications starting {
solveImplication {
  Implic {
    TcLevel = 1
    Skolems = (a_aVM[sk:1] :: k_a11t[tau:1])
    No-eqs = True
    Status = Unsolved
    Given =
    Wanted =
      WC {wc_simple =
            [WD] hole{co_a11E} {0}:: 'GHC.Types.LiftedRep
                                     GHC.Prim.~# t_a11s[tau:0] (CNonCanonical)}
    Binds = NoEvBindsVar<a11F>
    ‘forall a_aVM. (a_aVM ~ [F a_aVM]) => a_aVM -> Bool’ }
  Inerts {Unsolved goals = 0}
         Inert fsks = []
solveWanteds {
  WC {wc_simple =
        [WD] hole{co_a11E} {0}:: 'GHC.Types.LiftedRep
                                 GHC.Prim.~# t_a11s[tau:0] (CNonCanonical)}
solveSimpleWanteds {
  {[WD] hole{co_a11E} {0}:: 'GHC.Types.LiftedRep
                            GHC.Prim.~# t_a11s[tau:0] (CNonCanonical)}
----------------------------- 
Start solver pipeline {
  tclevel = 1
  work item = [WD] hole{co_a11E} {0}:: 'GHC.Types.LiftedRep
                                       GHC.Prim.~# t_a11s[tau:0] (CNonCanonical)
  inerts = {Unsolved goals = 0}
           Inert fsks = []
  rest of worklist = WL {}
runStage canonicalization {
  workitem   =  [WD] hole{co_a11E} {0}:: 'GHC.Types.LiftedRep
                                         GHC.Prim.~# t_a11s[tau:0] (CNonCanonical)
canEvNC:eq
  'GHC.Types.LiftedRep
  t_a11s[tau:0]
can_eq_nc
  False
  [WD] hole{co_a11E} {0}:: 'GHC.Types.LiftedRep
                           GHC.Prim.~# t_a11s[tau:0]
  nominal equality
  'GHC.Types.LiftedRep
  'GHC.Types.LiftedRep
  t_a11s[tau:0]
  t_a11s[tau:0]
flatten { FM_FlattenAll 'GHC.Types.LiftedRep
flatten } 'GHC.Types.LiftedRep
flatten { FM_FlattenAll t_a11s[tau:0]
Unfilled tyvar t_a11s[tau:0]
flatten } t_a11s[tau:0]
New coercion hole: co_a11H
Emitting new coercion hole
  {co_a11H} :: t_a11s[tau:0] GHC.Prim.~# 'GHC.Types.LiftedRep
Filling coercion hole co_a11E := Sym {co_a11H}
rewriteEqEvidence
  [WD] hole{co_a11E} {0}:: 'GHC.Types.LiftedRep
                           GHC.Prim.~# t_a11s[tau:0]
  t_a11s[tau:0]
  'GHC.Types.LiftedRep
  Sym {co_a11H}
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] hole{co_a11H} {1}:: t_a11s[tau:0]
                                         GHC.Prim.~# 'GHC.Types.LiftedRep (CTyEqCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [WD] hole{co_a11H} {1}:: t_a11s[tau:0]
                                         GHC.Prim.~# 'GHC.Types.LiftedRep (CTyEqCan)
doTopReact
  [WD] hole{co_a11H} {1}:: t_a11s[tau:0]
                           GHC.Prim.~# 'GHC.Types.LiftedRep (CTyEqCan)
end stage top-level reactions }
insertInertCan {
  Trying to insert new inert item: [WD] hole{co_a11H} {1}:: t_a11s[tau:0]
                                                            GHC.Prim.~# 'GHC.Types.LiftedRep (CTyEqCan)
addInertCan }
Step 1[l:1,d:1] Kept as inert:
    [WD] hole{co_a11H} {1}:: t_a11s[tau:0]
                             GHC.Prim.~# 'GHC.Types.LiftedRep
End solver pipeline (kept as inert) }
  final_item = [WD] hole{co_a11H} {1}:: t_a11s[tau:0]
                                        GHC.Prim.~# 'GHC.Types.LiftedRep (CTyEqCan)
getUnsolvedInerts
   tv eqs = {[WD] hole{co_a11H} {1}:: t_a11s[tau:0]
                                      GHC.Prim.~# 'GHC.Types.LiftedRep (CTyEqCan)}
  fun eqs = {}
  others = {}
  implics = {}
Unflattening
  {Funeqs =
   Tv eqs = [WD] hole{co_a11H} {1}:: t_a11s[tau:0]
                                     GHC.Prim.~# 'GHC.Types.LiftedRep (CTyEqCan)}
Unflattening 1 {}
Unflattening 2
  {[WD] hole{co_a11H} {1}:: t_a11s[tau:0]
                            GHC.Prim.~# 'GHC.Types.LiftedRep (CTyEqCan)}
Unflattening 3 {}
Unflattening done
  {[WD] hole{co_a11H} {1}:: t_a11s[tau:0]
                            GHC.Prim.~# 'GHC.Types.LiftedRep (CNonCanonical)}
solveSimpleWanteds end }
  iterations = 1
  residual = WC {wc_simple =
                   [WD] hole{co_a11H} {1}:: t_a11s[tau:0]
                                            GHC.Prim.~# 'GHC.Types.LiftedRep (CNonCanonical)}
solveWanteds }
  final wc = WC {wc_simple =
                   [WD] hole{co_a11H} {1}:: t_a11s[tau:0]
                                            GHC.Prim.~# 'GHC.Types.LiftedRep (CNonCanonical)}
  current evbinds  = {}
getNoGivenEqs
  No given equalities
  Skols: [a_aVM[sk:1]]
  Inerts: {Unsolved goals = 0}
  Insols: {}
unflattenGivens []
zonkSimples done:
  {[WD] hole{co_a11H} {1}:: t_a11s[tau:0]
                            GHC.Prim.~# 'GHC.Types.LiftedRep (CNonCanonical)}
floatEqualities
  Skols = [a_aVM[sk:1]]
  Extended skols = [aVM :-> a_aVM[sk:1]]
  Simples = {[WD] hole{co_a11H} {1}:: t_a11s[tau:0]
                                      GHC.Prim.~# 'GHC.Types.LiftedRep (CNonCanonical)}
  Eqs = {[WD] hole{co_a11H} {1}:: t_a11s[tau:0]
                                  GHC.Prim.~# 'GHC.Types.LiftedRep (CNonCanonical)}
  Floated eqs = {[WD] hole{co_a11H} {1}:: t_a11s[tau:0]
                                          GHC.Prim.~# 'GHC.Types.LiftedRep (CNonCanonical)}
solveImplication 2
  {}
  WC {}
setImplicationStatus(all-solved) {
  Implic {
    TcLevel = 1
    Skolems = (a_aVM[sk:1] :: k_a11t[tau:1])
    No-eqs = True
    Status = Unsolved
    Given =
    Wanted = WC {}
    Binds = NoEvBindsVar<a11F>
    ‘forall a_aVM. (a_aVM ~ [F a_aVM]) => a_aVM -> Bool’ }
neededEvVars
  old_needs: []
  seeds3: [a11H :-> co_a11H]
  ev_binds: []
  live_ev_binds: []
setImplicationStatus(all-solved) }
  discard: False
  new_implic: Implic {
                TcLevel = 1
                Skolems = (a_aVM[sk:1] :: k_a11t[tau:1])
                No-eqs = True
                Status = Solved {Dead givens = []}
                Given =
                Wanted = WC {}
                Binds = NoEvBindsVar<a11F>
                ‘forall a_aVM. (a_aVM ~ [F a_aVM]) => a_aVM -> Bool’ }
solveImplication end }
  no_given_eqs = True
  floated_eqs = {[WD] hole{co_a11H} {1}:: t_a11s[tau:0]
                                          GHC.Prim.~# 'GHC.Types.LiftedRep (CNonCanonical)}
  res_implic = Just Implic {
                      TcLevel = 1
                      Skolems = (a_aVM[sk:1] :: k_a11t[tau:1])
                      No-eqs = True
                      Status = Solved {Dead givens = []}
                      Given =
                      Wanted = WC {}
                      Binds = NoEvBindsVar<a11F>
                      ‘forall a_aVM. (a_aVM ~ [F a_aVM]) => a_aVM -> Bool’ }
  implication evbinds = {}
  implication tvcs = [a11H :-> co_a11H]
solveNestedImplications end }
  all floated_eqs = {[WD] hole{co_a11H} {1}:: t_a11s[tau:0]
                                              GHC.Prim.~# 'GHC.Types.LiftedRep (CNonCanonical)}
  unsolved_implics = {Just Implic {
                             TcLevel = 1
                             Skolems = (a_aVM[sk:1] :: k_a11t[tau:1])
                             No-eqs = True
                             Status = Solved {Dead givens = []}
                             Given =
                             Wanted = WC {}
                             Binds = NoEvBindsVar<a11F>
                             ‘forall a_aVM. (a_aVM ~ [F a_aVM]) => a_aVM -> Bool’ }}
simpl_loop iteration=0 (no new given superclasses = True, 1 simples to solve)
simpl_loop: wc =
  WC {wc_simple =
        [WD] hole{co_a11H} {1}:: t_a11s[tau:0]
                                 GHC.Prim.~# 'GHC.Types.LiftedRep (CNonCanonical)
      wc_impl =
        Implic {
          TcLevel = 1
          Skolems = (a_aVM[sk:1] :: k_a11t[tau:1])
          No-eqs = True
          Status = Solved {Dead givens = []}
          Given =
          Wanted = WC {}
          Binds = NoEvBindsVar<a11F>
          ‘forall a_aVM. (a_aVM ~ [F a_aVM]) => a_aVM -> Bool’ }}
solveSimpleWanteds {
  {[WD] hole{co_a11H} {1}:: t_a11s[tau:0]
                            GHC.Prim.~# 'GHC.Types.LiftedRep (CNonCanonical)}
----------------------------- 
Start solver pipeline {
  tclevel = 0
  work item = [WD] hole{co_a11H} {1}:: t_a11s[tau:0]
                                       GHC.Prim.~# 'GHC.Types.LiftedRep (CNonCanonical)
  inerts = {Unsolved goals = 0}
           Inert fsks = []
  rest of worklist = WL {}
runStage canonicalization {
  workitem   =  [WD] hole{co_a11H} {1}:: t_a11s[tau:0]
                                         GHC.Prim.~# 'GHC.Types.LiftedRep (CNonCanonical)
canEvNC:eq
  t_a11s[tau:0]
  'GHC.Types.LiftedRep
can_eq_nc
  False
  [WD] hole{co_a11H} {1}:: t_a11s[tau:0]
                           GHC.Prim.~# 'GHC.Types.LiftedRep
  nominal equality
  t_a11s[tau:0]
  t_a11s[tau:0]
  'GHC.Types.LiftedRep
  'GHC.Types.LiftedRep
flatten { FM_FlattenAll t_a11s[tau:0]
Unfilled tyvar t_a11s[tau:0]
flatten } t_a11s[tau:0]
flatten { FM_FlattenAll 'GHC.Types.LiftedRep
flatten } 'GHC.Types.LiftedRep
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] hole{co_a11H} {1}:: t_a11s[tau:0]
                                         GHC.Prim.~# 'GHC.Types.LiftedRep (CTyEqCan)
Sneaky unification:
  Unifies: t_a11s[tau:0] := 'GHC.Types.LiftedRep
  Coercion: t_a11s[tau:0] ~ 'GHC.Types.LiftedRep
  Left Kind is: GHC.Types.RuntimeRep
  Right Kind is: GHC.Types.RuntimeRep
unifyTyVar t_a11s[tau:0] := 'GHC.Types.LiftedRep
writeMetaTyVar
  t_a11s[tau:0] :: GHC.Types.RuntimeRep := 'GHC.Types.LiftedRep
Filling coercion hole co_a11H := <'GHC.Types.LiftedRep>_N
end stage interact with inerts }
Step 2[l:0,d:1] Solved by unification:
    [WD] hole{co_a11H} {1}:: t_a11s[tau:0]
                             GHC.Prim.~# 'GHC.Types.LiftedRep
End solver pipeline (discharged) }
getUnsolvedInerts
   tv eqs = {}
  fun eqs = {}
  others = {}
  implics = {}
Unflattening
  {Funeqs =
   Tv eqs =}
Unflattening 1 {}
Unflattening 2 {}
Unflattening 3 {}
Unflattening done {}
solveSimpleWanteds end }
  iterations = 1
  residual = WC {}
solveNestedImplications starting {
solveNestedImplications end }
  all floated_eqs = {}
  unsolved_implics = {Just Implic {
                             TcLevel = 1
                             Skolems = (a_aVM[sk:1] :: k_a11t[tau:1])
                             No-eqs = True
                             Status = Solved {Dead givens = []}
                             Given =
                             Wanted = WC {}
                             Binds = NoEvBindsVar<a11F>
                             ‘forall a_aVM. (a_aVM ~ [F a_aVM]) => a_aVM -> Bool’ }}
solveWanteds }
  final wc = WC {wc_impl =
                   Implic {
                     TcLevel = 1
                     Skolems = (a_aVM[sk:1] :: k_a11t[tau:1])
                     No-eqs = True
                     Status = Solved {Dead givens = []}
                     Given =
                     Wanted = WC {}
                     Binds = NoEvBindsVar<a11F>
                     ‘forall a_aVM. (a_aVM ~ [F a_aVM]) => a_aVM -> Bool’ }}
  current evbinds  = {}
Constraint solver steps = 2
unflattenGivens []
solveLocalEqualities: running solver }
  WC {wc_impl =
        Implic {
          TcLevel = 1
          Skolems = (a_aVM[sk:1] :: k_a11t[tau:1])
          No-eqs = True
          Status = Solved {Dead givens = []}
          Given =
          Wanted = WC {}
          Binds = NoEvBindsVar<a11F>
          ‘forall a_aVM. (a_aVM ~ [F a_aVM]) => a_aVM -> Bool’ }}
solveLocalEqualities end }
solveEqualities {
  wanted =  WC {wc_impl =
                  Implic {
                    TcLevel = 1
                    Skolems = (a_aVM[sk:1] :: k_a11t[tau:1])
                    No-eqs = True
                    Status = Solved {Dead givens = []}
                    Given =
                    Wanted = WC {}
                    Binds = NoEvBindsVar<a11F>
                    ‘forall a_aVM. (a_aVM ~ [F a_aVM]) => a_aVM -> Bool’ }}
newNoTcEvBinds unique = a11I
solveWanteds {
  WC {wc_impl =
        Implic {
          TcLevel = 1
          Skolems = (a_aVM[sk:1] :: k_a11t[tau:1])
          No-eqs = True
          Status = Solved {Dead givens = []}
          Given =
          Wanted = WC {}
          Binds = NoEvBindsVar<a11F>
          ‘forall a_aVM. (a_aVM ~ [F a_aVM]) => a_aVM -> Bool’ }}
solveSimpleWanteds { {}
solveSimpleWanteds end }
  iterations = 1
  residual = WC {}
solveNestedImplications starting {
solveNestedImplications end }
  all floated_eqs = {}
  unsolved_implics = {Just Implic {
                             TcLevel = 1
                             Skolems = (a_aVM[sk:1] :: k_a11t[tau:1])
                             No-eqs = True
                             Status = Solved {Dead givens = []}
                             Given =
                             Wanted = WC {}
                             Binds = NoEvBindsVar<a11F>
                             ‘forall a_aVM. (a_aVM ~ [F a_aVM]) => a_aVM -> Bool’ }}
solveWanteds }
  final wc = WC {wc_impl =
                   Implic {
                     TcLevel = 1
                     Skolems = (a_aVM[sk:1] :: k_a11t[tau:1])
                     No-eqs = True
                     Status = Solved {Dead givens = []}
                     Given =
                     Wanted = WC {}
                     Binds = NoEvBindsVar<a11F>
                     ‘forall a_aVM. (a_aVM ~ [F a_aVM]) => a_aVM -> Bool’ }}
  current evbinds  = {}
zonkSimples done: {}
zonkSimples done: {}
applyDefaultingRules {
  wanteds = WC {wc_impl =
                  Implic {
                    TcLevel = 1
                    Skolems = a_aVM[sk:1]
                    No-eqs = True
                    Status = Solved {Dead givens = []}
                    Given =
                    Wanted = WC {}
                    Binds = NoEvBindsVar<a11F>
                    ‘forall a_aVM. (a_aVM ~ [F a_aVM]) => a_aVM -> Bool’ }}
  groups  = []
  info    = ([Integer, Double], (False, False))
applyDefaultingRules } []
unflattenGivens []
End solveEqualities }
reportAllUnsolved {
newNoTcEvBinds unique = a1cb
reportUnsolved warning/error settings:
  type errors: TypeError
  expr holes: HoleError
  type holes: HoleError
  scope holes: HoleError
reportUnsolved (before zonking and tidying)
  WC {wc_impl =
        Implic {
          TcLevel = 1
          Skolems = (a_aVM[sk:1] :: k_a11t[tau:1])
          No-eqs = True
          Status = Solved {Dead givens = []}
          Given =
          Wanted = WC {}
          Binds = NoEvBindsVar<a11F>
          ‘forall a_aVM. (a_aVM ~ [F a_aVM]) => a_aVM -> Bool’ }}
zonkSimples done: {}
zonkSimples done: {}
reportUnsolved (after zonking):
  Free tyvars:
  Tidy env: ([], [])
  Wanted: WC {wc_impl =
                Implic {
                  TcLevel = 1
                  Skolems = a_aVM[sk:1]
                  No-eqs = True
                  Status = Solved {Dead givens = []}
                  Given =
                  Wanted = WC {}
                  Binds = NoEvBindsVar<a11F>
                  ‘forall a_aVM. (a_aVM ~ [F a_aVM]) => a_aVM -> Bool’ }}
reportWanteds
  Simples = {}
  Suppress = False
rw2 []
tryReporters {
  []
  []
tryReporters } []
tryReporters {
  []
  []
tryReporters } []
reportImplic
  Implic {
    TcLevel = 1
    Skolems = a_aVM[sk:1]
    No-eqs = True
    Status = Solved {Dead givens = []}
    Given =
    Wanted = WC {}
    Binds = NoEvBindsVar<a11F>
    ‘forall a_aVM. (a_aVM ~ [F a_aVM]) => a_aVM -> Bool’ }
reportWanteds
  Simples = {}
  Suppress = False
rw2 []
tryReporters {
  []
  []
tryReporters } []
tryReporters {
  []
  []
tryReporters } []
reportAllUnsolved }
quantifyTyVars
  DV {dv_kvs = [] dv_tvs = []}
  []
quantifyTyVars
  globals: []
  nondep:
  dep:
  dep_kvs'
  nondep_tvs'
checkValidType forall a. (a ~ [F a]) => a -> Bool :: *
check_type
  forall a. (a ~ [F a]) => a -> Bool
  True
check_valid_theta [a_aVM[sk:0] ~ [F a_aVM[sk:0]]]
Ambiguity check for forall a. (a ~ [F a]) => a -> Bool
tcSubType_NC
  the type signature for ‘asdf’
  forall a. (a ~ [F a]) => a -> Bool
  forall a. (a ~ [F a]) => a -> Bool
tc_sub_tc_type (general case)
  ty_actual   = forall a. (a ~ [F a]) => a -> Bool
  ty_expected = forall a. (a ~ [F a]) => a -> Bool
tcSkolemise
tc_sub_type_ds
  ty_actual   = forall a. (a ~ [F a]) => a -> Bool
  ty_expected = a_a1cd[sk:1] -> Bool
cloneAnonMetaTyVar a_a1cf[tau:1]
instCallConstraints [$d~_a1cg]
Instantiating
  all tyvars? True
  origin arising from a type equality forall a.
                                      (a ~ [F a]) =>
                                      a -> Bool
                                      ~
                                      forall a. (a ~ [F a]) => a -> Bool
  type forall @a_aVM[sk:1].
         (a_aVM[sk:0] ~ [F a_aVM[sk:0]]) => a_aVM[sk:0] -> Bool
  theta [a_aVM[sk:0] ~ [F a_aVM[sk:0]]]
  leave_bndrs []
  with a_a1cf[tau:1]
  theta: [a_a1cf[tau:1] ~ [F a_a1cf[tau:1]]]
tc_sub_type_ds
  ty_actual   = a_a1cf[tau:1] -> Bool
  ty_expected = a_a1cd[sk:1] -> Bool
tc_sub_type_ds
  ty_actual   = Bool
  ty_expected = Bool
deeply_instantiate final subst
  origin: arising from a type equality forall a.
                                       (a ~ [F a]) =>
                                       a -> Bool
                                       ~
                                       forall a. (a ~ [F a]) => a -> Bool
  type: Bool
  new type: Bool
  subst: [TCvSubst In scope: InScope {} Type env: [] Co env: []]
u_tys
  tclvl 1
  Bool ~ Bool
  arising from a type equality a_a1cf[tau:1] -> Bool
                               ~
                               a_a1cd[sk:1] -> Bool
u_tys yields no coercion
tc_sub_tc_type (general case)
  ty_actual   = a_a1cd[sk:1]
  ty_expected = a_a1cf[tau:1]
tcSkolemise
tc_sub_type_ds
  ty_actual   = a_a1cd[sk:1]
  ty_expected = a_a1cf[tau:1]
u_tys
  tclvl 1
  a_a1cd[sk:1] ~ a_a1cf[tau:1]
  arising from a type equality a_a1cf[tau:1] -> Bool
                               ~
                               a_a1cd[sk:1] -> Bool
u_tys
  tclvl 1
  * ~ *
  arising from a kind equality arising from
    a_a1cf[tau:1] ~ a_a1cd[sk:1]
u_tys
  tclvl 1
  'GHC.Types.LiftedRep ~ 'GHC.Types.LiftedRep
  arising from a kind equality arising from
    a_a1cf[tau:1] ~ a_a1cd[sk:1]
u_tys yields no coercion
u_tys yields no coercion
writeMetaTyVar a_a1cf[tau:1] :: * := a_a1cd[sk:1]
u_tys yields no coercion
newTcEvBinds unique = a1ch
checkConstraints
  1
  [a_a1cd[sk:1]]
simplifyAmbiguityCheck {
  type =  forall a. (a ~ [F a]) => a -> Bool
  wanted =  WC {wc_impl =
                  Implic {
                    TcLevel = 1
                    Skolems = a_a1cd[sk:1]
                    No-eqs = False
                    Status = Unsolved
                    Given = $d~_a1ce :: a_a1cd[sk:1] ~ [F a_a1cd[sk:1]]
                    Wanted =
                      WC {wc_simple =
                            [WD] $d~_a1cg {0}:: a_a1cf[tau:1]
                                                ~ [F a_a1cf[tau:1]] (CNonCanonical)}
                    Binds = EvBindsVar<a1ch>
                    the type signature for:
                      asdf :: forall a. (a ~ [F a]) => a -> Bool }}
newTcEvBinds unique = a1ci
solveWanteds {
  WC {wc_impl =
        Implic {
          TcLevel = 1
          Skolems = a_a1cd[sk:1]
          No-eqs = False
          Status = Unsolved
          Given = $d~_a1ce :: a_a1cd[sk:1] ~ [F a_a1cd[sk:1]]
          Wanted =
            WC {wc_simple =
                  [WD] $d~_a1cg {0}:: a_a1cf[tau:1]
                                      ~ [F a_a1cf[tau:1]] (CNonCanonical)}
          Binds = EvBindsVar<a1ch>
          the type signature for:
            asdf :: forall a. (a ~ [F a]) => a -> Bool }}
solveSimpleWanteds { {}
solveSimpleWanteds end }
  iterations = 1
  residual = WC {}
solveNestedImplications starting {
solveImplication {
  Implic {
    TcLevel = 1
    Skolems = a_a1cd[sk:1]
    No-eqs = False
    Status = Unsolved
    Given = $d~_a1ce :: a_a1cd[sk:1] ~ [F a_a1cd[sk:1]]
    Wanted =
      WC {wc_simple =
            [WD] $d~_a1cg {0}:: a_a1cf[tau:1]
                                ~ [F a_a1cf[tau:1]] (CNonCanonical)}
    Binds = EvBindsVar<a1ch>
    the type signature for:
      asdf :: forall a. (a ~ [F a]) => a -> Bool }
  Inerts {Unsolved goals = 0}
         Inert fsks = []
solveSimpleGivens {
  [[G] $d~_a1ce {0}:: a_a1cd[sk:1]
                      ~ [F a_a1cd[sk:1]] (CNonCanonical)]
----------------------------- 
Start solver pipeline {
  tclevel = 1
  work item = [G] $d~_a1ce {0}:: a_a1cd[sk:1]
                                 ~ [F a_a1cd[sk:1]] (CNonCanonical)
  inerts = {Unsolved goals = 0}
           Inert fsks = []
  rest of worklist = WL {}
runStage canonicalization {
  workitem   =  [G] $d~_a1ce {0}:: a_a1cd[sk:1]
                                   ~ [F a_a1cd[sk:1]] (CNonCanonical)
canEvNC:cls ~ [*, a_a1cd[sk:1], [F a_a1cd[sk:1]]]
addTcEvBind
  a1ch
  [G] $d~~_a1cj
    = Data.Type.Equality.$p1~
        @ * @ a_a1cd[sk:1] @ [F a_a1cd[sk:1]] $d~_a1ce
mk_superclasses_of
  ~~ [*, *, a_a1cd[sk:1], [F a_a1cd[sk:1]]]
  False
  [31e :-> ~]
addTcEvBind
  a1ch
  [G] co_a1ck
    = GHC.Types.heq_sel
        @ * @ * @ a_a1cd[sk:1] @ [F a_a1cd[sk:1]] $d~~_a1cj
Emitting fresh work
  [G] $d~~_a1cj {0}:: a_a1cd[sk:1] ~~ [F a_a1cd[sk:1]] (CDictCan)
  [G] co_a1ck {0}:: a_a1cd[sk:1]
                    GHC.Prim.~# [F a_a1cd[sk:1]] (CNonCanonical)
flatten_args {
  *
  a_a1cd[sk:1]
  [F a_a1cd[sk:1]]
Unfilled tyvar a_a1cd[sk:1]
matchFamTcM
  Matching: F a_a1cd[sk:1]
  Match failed
Unfilled tyvar a_a1cd[sk:1]
matchFamTcM
  Matching: F a_a1cd[sk:1]
  Match failed
addTcEvBind
  a1ch
  [G] co_a1cm = CO: <F a_a1cd[sk:1]>_N
extendFlatCache
  F [a_a1cd[sk:1]]
  [G]
  fsk_a1cl[fsk:1]
flatten/flat-cache miss
  F [a_a1cd[sk:1]]
  fsk_a1cl[fsk:1]
  [G] co_a1cm {0}:: F a_a1cd[sk:1] GHC.Prim.~# fsk_a1cl[fsk:1]
flatten }
  *
  a_a1cd[sk:1]
  [fsk_a1cl[fsk:1]]
canClass
  [G] $d~_a1ce {0}:: a_a1cd[sk:1] ~ [F a_a1cd[sk:1]]
  a_a1cd[sk:1] ~ [fsk_a1cl[fsk:1]]
  ContinueWith [G] $d~_a1ce {0}:: a_a1cd[sk:1] ~ [fsk_a1cl[fsk:1]]
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [G] $d~_a1ce {0}:: a_a1cd[sk:1]
                                   ~ [fsk_a1cl[fsk:1]] (CDictCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [G] $d~_a1ce {0}:: a_a1cd[sk:1]
                                   ~ [fsk_a1cl[fsk:1]] (CDictCan)
doTopReact
  [G] $d~_a1ce {0}:: a_a1cd[sk:1] ~ [fsk_a1cl[fsk:1]] (CDictCan)
try_fundeps
  [G] $d~_a1ce {0}:: a_a1cd[sk:1] ~ [fsk_a1cl[fsk:1]] (CDictCan)
end stage top-level reactions }
insertInertCan {
  Trying to insert new inert item: [G] $d~_a1ce {0}:: a_a1cd[sk:1]
                                                      ~ [fsk_a1cl[fsk:1]] (CDictCan)
addInertCan }
Step 1[l:1,d:0] Kept as inert:
    [G] $d~_a1ce {0}:: a_a1cd[sk:1] ~ [fsk_a1cl[fsk:1]]
End solver pipeline (kept as inert) }
  final_item = [G] $d~_a1ce {0}:: a_a1cd[sk:1]
                                  ~ [fsk_a1cl[fsk:1]] (CDictCan)
----------------------------- 
Start solver pipeline {
  tclevel = 1
  work item = [G] $d~~_a1cj {0}:: a_a1cd[sk:1]
                                  ~~ [F a_a1cd[sk:1]] (CDictCan)
  inerts = {Dictionaries = [G] $d~_a1ce {0}:: a_a1cd[sk:1]
                                              ~ [fsk_a1cl[fsk:1]] (CDictCan)
            Unsolved goals = 0}
           Inert fsks = [(fsk_a1cl[fsk:1], F a_a1cd[sk:1])]
  rest of worklist = WL {Eqs = [G] co_a1ck {0}:: a_a1cd[sk:1]
                                                 GHC.Prim.~# [F a_a1cd[sk:1]] (CNonCanonical)
                         Funeqs = [G] co_a1cm {0}:: F a_a1cd[sk:1]
                                                    GHC.Prim.~# fsk_a1cl[fsk:1] (CFunEqCan)}
runStage canonicalization {
  workitem   =  [G] $d~~_a1cj {0}:: a_a1cd[sk:1]
                                    ~~ [F a_a1cd[sk:1]] (CDictCan)
flatten_args {
  *
  *
  a_a1cd[sk:1]
  [F a_a1cd[sk:1]]
Unfilled tyvar a_a1cd[sk:1]
matchFamTcM
  Matching: F a_a1cd[sk:1]
  Match failed
Unfilled tyvar a_a1cd[sk:1]
flatten/flat-cache hit
  F [a_a1cd[sk:1]]
  fsk_a1cl[fsk:1]
Unfilled tyvar fsk_a1cl[fsk:1]
flatten }
  *
  *
  a_a1cd[sk:1]
  [fsk_a1cl[fsk:1]]
canClass
  [G] $d~~_a1cj {0}:: a_a1cd[sk:1] ~~ [F a_a1cd[sk:1]]
  a_a1cd[sk:1] ~~ [fsk_a1cl[fsk:1]]
  ContinueWith [G] $d~~_a1cj {0}:: a_a1cd[sk:1] ~~ [fsk_a1cl[fsk:1]]
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [G] $d~~_a1cj {0}:: a_a1cd[sk:1]
                                    ~~ [fsk_a1cl[fsk:1]] (CDictCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [G] $d~~_a1cj {0}:: a_a1cd[sk:1]
                                    ~~ [fsk_a1cl[fsk:1]] (CDictCan)
doTopReact
  [G] $d~~_a1cj {0}:: a_a1cd[sk:1] ~~ [fsk_a1cl[fsk:1]] (CDictCan)
try_fundeps
  [G] $d~~_a1cj {0}:: a_a1cd[sk:1] ~~ [fsk_a1cl[fsk:1]] (CDictCan)
end stage top-level reactions }
insertInertCan {
  Trying to insert new inert item: [G] $d~~_a1cj {0}:: a_a1cd[sk:1]
                                                       ~~ [fsk_a1cl[fsk:1]] (CDictCan)
addInertCan }
Step 2[l:1,d:0] Kept as inert:
    [G] $d~~_a1cj {0}:: a_a1cd[sk:1] ~~ [fsk_a1cl[fsk:1]]
End solver pipeline (kept as inert) }
  final_item = [G] $d~~_a1cj {0}:: a_a1cd[sk:1]
                                   ~~ [fsk_a1cl[fsk:1]] (CDictCan)
----------------------------- 
Start solver pipeline {
  tclevel = 1
  work item = [G] co_a1ck {0}:: a_a1cd[sk:1]
                                GHC.Prim.~# [F a_a1cd[sk:1]] (CNonCanonical)
  inerts = {Dictionaries = [G] $d~_a1ce {0}:: a_a1cd[sk:1]
                                              ~ [fsk_a1cl[fsk:1]] (CDictCan)
                           [G] $d~~_a1cj {0}:: a_a1cd[sk:1] ~~ [fsk_a1cl[fsk:1]] (CDictCan)
            Unsolved goals = 0}
           Inert fsks = [(fsk_a1cl[fsk:1], F a_a1cd[sk:1])]
  rest of worklist = WL {Funeqs = [G] co_a1cm {0}:: F a_a1cd[sk:1]
                                                    GHC.Prim.~# fsk_a1cl[fsk:1] (CFunEqCan)}
runStage canonicalization {
  workitem   =  [G] co_a1ck {0}:: a_a1cd[sk:1]
                                  GHC.Prim.~# [F a_a1cd[sk:1]] (CNonCanonical)
canEvNC:eq
  a_a1cd[sk:1]
  [F a_a1cd[sk:1]]
can_eq_nc
  False
  [G] co_a1ck {0}:: a_a1cd[sk:1] GHC.Prim.~# [F a_a1cd[sk:1]]
  nominal equality
  a_a1cd[sk:1]
  a_a1cd[sk:1]
  [F a_a1cd[sk:1]]
  [F a_a1cd[sk:1]]
flatten { FM_FlattenAll a_a1cd[sk:1]
Unfilled tyvar a_a1cd[sk:1]
flatten } a_a1cd[sk:1]
flatten { FM_FlattenAll [F a_a1cd[sk:1]]
matchFamTcM
  Matching: F a_a1cd[sk:1]
  Match failed
Unfilled tyvar a_a1cd[sk:1]
flatten/flat-cache hit
  F [a_a1cd[sk:1]]
  fsk_a1cl[fsk:1]
Unfilled tyvar fsk_a1cl[fsk:1]
flatten } [fsk_a1cl[fsk:1]]
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [G] co_a1ck {0}:: a_a1cd[sk:1]
                                  GHC.Prim.~# [fsk_a1cl[fsk:1]] (CTyEqCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [G] co_a1ck {0}:: a_a1cd[sk:1]
                                  GHC.Prim.~# [fsk_a1cl[fsk:1]] (CTyEqCan)
doTopReact
  [G] co_a1ck {0}:: a_a1cd[sk:1]
                    GHC.Prim.~# [fsk_a1cl[fsk:1]] (CTyEqCan)
end stage top-level reactions }
insertInertCan {
  Trying to insert new inert item: [G] co_a1ck {0}:: a_a1cd[sk:1]
                                                     GHC.Prim.~# [fsk_a1cl[fsk:1]] (CTyEqCan)
Kick out, tv = a_a1cd[sk:1]
  n-kicked = 2
  kicked_out = WL {Eqs = [G] $d~_a1ce {0}:: a_a1cd[sk:1]
                                            ~ [fsk_a1cl[fsk:1]] (CDictCan)
                         [G] $d~~_a1cj {0}:: a_a1cd[sk:1] ~~ [fsk_a1cl[fsk:1]] (CDictCan)}
  Residual inerts = {Unsolved goals = 0}
addInertCan }
Step 3[l:1,d:0] Kept as inert:
    [G] co_a1ck {0}:: a_a1cd[sk:1] GHC.Prim.~# [fsk_a1cl[fsk:1]]
End solver pipeline (kept as inert) }
  final_item = [G] co_a1ck {0}:: a_a1cd[sk:1]
                                 GHC.Prim.~# [fsk_a1cl[fsk:1]] (CTyEqCan)
----------------------------- 
Start solver pipeline {
  tclevel = 1
  work item = [G] $d~_a1ce {0}:: a_a1cd[sk:1]
                                 ~ [fsk_a1cl[fsk:1]] (CDictCan)
  inerts = {Equalities: [G] co_a1ck {0}:: a_a1cd[sk:1]
                                          GHC.Prim.~# [fsk_a1cl[fsk:1]] (CTyEqCan)
            Unsolved goals = 0}
           Inert fsks = [(fsk_a1cl[fsk:1], F a_a1cd[sk:1])]
  rest of worklist = WL {Eqs = [G] $d~~_a1cj {0}:: a_a1cd[sk:1]
                                                   ~~ [fsk_a1cl[fsk:1]] (CDictCan)
                         Funeqs = [G] co_a1cm {0}:: F a_a1cd[sk:1]
                                                    GHC.Prim.~# fsk_a1cl[fsk:1] (CFunEqCan)}
runStage canonicalization {
  workitem   =  [G] $d~_a1ce {0}:: a_a1cd[sk:1]
                                   ~ [fsk_a1cl[fsk:1]] (CDictCan)
flatten_args {
  *
  a_a1cd[sk:1]
  [fsk_a1cl[fsk:1]]
Unfilled tyvar a_a1cd[sk:1]
Following inert tyvar
  FM_FlattenAll a_a1cd[sk:1] = [fsk_a1cl[fsk:1]]
  [G] co_a1ck {0}:: a_a1cd[sk:1] GHC.Prim.~# [fsk_a1cl[fsk:1]]
Unfilled tyvar fsk_a1cl[fsk:1]
Unfilled tyvar fsk_a1cl[fsk:1]
flatten }
  *
  [fsk_a1cl[fsk:1]]
  [fsk_a1cl[fsk:1]]
addTcEvBind
  a1ch
  [G] $d~_a1cn
    = $d~_a1ce
      `cast` (Sub (Sym ((~) <*>_N (Sym co_a1ck) <[fsk_a1cl[fsk:1]]>_N)_N)
              :: (a_a1cd[sk:1] ~ [fsk_a1cl[fsk:1]])
                 ~R# ([F a_a1cd[sk:1]] ~ [fsk_a1cl[fsk:1]]))
canClass
  [G] $d~_a1ce {0}:: a_a1cd[sk:1] ~ [fsk_a1cl[fsk:1]]
  [fsk_a1cl[fsk:1]] ~ [fsk_a1cl[fsk:1]]
  ContinueWith [G] $d~_a1cn {0}:: [fsk_a1cl[fsk:1]]
                                  ~ [fsk_a1cl[fsk:1]]
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [G] $d~_a1cn {0}:: [fsk_a1cl[fsk:1]]
                                   ~ [fsk_a1cl[fsk:1]] (CDictCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [G] $d~_a1cn {0}:: [fsk_a1cl[fsk:1]]
                                   ~ [fsk_a1cl[fsk:1]] (CDictCan)
doTopReact
  [G] $d~_a1cn {0}:: [fsk_a1cl[fsk:1]] ~ [fsk_a1cl[fsk:1]] (CDictCan)
try_fundeps
  [G] $d~_a1cn {0}:: [fsk_a1cl[fsk:1]] ~ [fsk_a1cl[fsk:1]] (CDictCan)
end stage top-level reactions }
insertInertCan {
  Trying to insert new inert item: [G] $d~_a1cn {0}:: [fsk_a1cl[fsk:1]]
                                                      ~ [fsk_a1cl[fsk:1]] (CDictCan)
addInertCan }
Step 4[l:1,d:0] Kept as inert:
    [G] $d~_a1cn {0}:: [fsk_a1cl[fsk:1]] ~ [fsk_a1cl[fsk:1]]
End solver pipeline (kept as inert) }
  final_item = [G] $d~_a1cn {0}:: [fsk_a1cl[fsk:1]]
                                  ~ [fsk_a1cl[fsk:1]] (CDictCan)
----------------------------- 
Start solver pipeline {
  tclevel = 1
  work item = [G] $d~~_a1cj {0}:: a_a1cd[sk:1]
                                  ~~ [fsk_a1cl[fsk:1]] (CDictCan)
  inerts = {Equalities: [G] co_a1ck {0}:: a_a1cd[sk:1]
                                          GHC.Prim.~# [fsk_a1cl[fsk:1]] (CTyEqCan)
            Dictionaries = [G] $d~_a1cn {0}:: [fsk_a1cl[fsk:1]]
                                              ~ [fsk_a1cl[fsk:1]] (CDictCan)
            Unsolved goals = 0}
           Inert fsks = [(fsk_a1cl[fsk:1], F a_a1cd[sk:1])]
  rest of worklist = WL {Funeqs = [G] co_a1cm {0}:: F a_a1cd[sk:1]
                                                    GHC.Prim.~# fsk_a1cl[fsk:1] (CFunEqCan)}
runStage canonicalization {
  workitem   =  [G] $d~~_a1cj {0}:: a_a1cd[sk:1]
                                    ~~ [fsk_a1cl[fsk:1]] (CDictCan)
flatten_args {
  *
  *
  a_a1cd[sk:1]
  [fsk_a1cl[fsk:1]]
Unfilled tyvar a_a1cd[sk:1]
Following inert tyvar
  FM_FlattenAll a_a1cd[sk:1] = [fsk_a1cl[fsk:1]]
  [G] co_a1ck {0}:: a_a1cd[sk:1] GHC.Prim.~# [fsk_a1cl[fsk:1]]
Unfilled tyvar fsk_a1cl[fsk:1]
Unfilled tyvar fsk_a1cl[fsk:1]
flatten }
  *
  *
  [fsk_a1cl[fsk:1]]
  [fsk_a1cl[fsk:1]]
addTcEvBind
  a1ch
  [G] $d~~_a1co
    = $d~~_a1cj
      `cast` (Sub (Sym ((~~)
                          <*>_N <*>_N (Sym co_a1ck) <[fsk_a1cl[fsk:1]]>_N)_N)
              :: (a_a1cd[sk:1] ~~ [fsk_a1cl[fsk:1]])
                 ~R# ([F a_a1cd[sk:1]] ~~ [fsk_a1cl[fsk:1]]))
canClass
  [G] $d~~_a1cj {0}:: a_a1cd[sk:1] ~~ [fsk_a1cl[fsk:1]]
  [fsk_a1cl[fsk:1]] ~~ [fsk_a1cl[fsk:1]]
  ContinueWith [G] $d~~_a1co {0}:: [fsk_a1cl[fsk:1]]
                                   ~~ [fsk_a1cl[fsk:1]]
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [G] $d~~_a1co {0}:: [fsk_a1cl[fsk:1]]
                                    ~~ [fsk_a1cl[fsk:1]] (CDictCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [G] $d~~_a1co {0}:: [fsk_a1cl[fsk:1]]
                                    ~~ [fsk_a1cl[fsk:1]] (CDictCan)
doTopReact
  [G] $d~~_a1co {0}:: [fsk_a1cl[fsk:1]]
                      ~~ [fsk_a1cl[fsk:1]] (CDictCan)
try_fundeps
  [G] $d~~_a1co {0}:: [fsk_a1cl[fsk:1]]
                      ~~ [fsk_a1cl[fsk:1]] (CDictCan)
end stage top-level reactions }
insertInertCan {
  Trying to insert new inert item: [G] $d~~_a1co {0}:: [fsk_a1cl[fsk:1]]
                                                       ~~ [fsk_a1cl[fsk:1]] (CDictCan)
addInertCan }
Step 5[l:1,d:0] Kept as inert:
    [G] $d~~_a1co {0}:: [fsk_a1cl[fsk:1]] ~~ [fsk_a1cl[fsk:1]]
End solver pipeline (kept as inert) }
  final_item = [G] $d~~_a1co {0}:: [fsk_a1cl[fsk:1]]
                                   ~~ [fsk_a1cl[fsk:1]] (CDictCan)
----------------------------- 
Start solver pipeline {
  tclevel = 1
  work item = [G] co_a1cm {0}:: F a_a1cd[sk:1]
                                GHC.Prim.~# fsk_a1cl[fsk:1] (CFunEqCan)
  inerts = {Equalities: [G] co_a1ck {0}:: a_a1cd[sk:1]
                                          GHC.Prim.~# [fsk_a1cl[fsk:1]] (CTyEqCan)
            Dictionaries = [G] $d~_a1cn {0}:: [fsk_a1cl[fsk:1]]
                                              ~ [fsk_a1cl[fsk:1]] (CDictCan)
                           [G] $d~~_a1co {0}:: [fsk_a1cl[fsk:1]]
                                               ~~ [fsk_a1cl[fsk:1]] (CDictCan)
            Unsolved goals = 0}
           Inert fsks = [(fsk_a1cl[fsk:1], F a_a1cd[sk:1])]
  rest of worklist = WL {}
runStage canonicalization {
  workitem   =  [G] co_a1cm {0}:: F a_a1cd[sk:1]
                                  GHC.Prim.~# fsk_a1cl[fsk:1] (CFunEqCan)
flatten_args { a_a1cd[sk:1]
Unfilled tyvar a_a1cd[sk:1]
Following inert tyvar
  FM_FlattenAll a_a1cd[sk:1] = [fsk_a1cl[fsk:1]]
  [G] co_a1ck {0}:: a_a1cd[sk:1] GHC.Prim.~# [fsk_a1cl[fsk:1]]
Unfilled tyvar fsk_a1cl[fsk:1]
flatten } [fsk_a1cl[fsk:1]]
canCFunEqCan: refl
  F [fsk_a1cl[fsk:1]]
  (F (Sym co_a1ck))_N
addTcEvBind
  a1ch
  [G] co_a1cp = CO: (F (Sym co_a1ck))_N ; co_a1cm
extendFlatCache
  F [[fsk_a1cl[fsk:1]]]
  [G]
  fsk_a1cl[fsk:1]
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [G] co_a1cp {1}:: F [fsk_a1cl[fsk:1]]
                                  GHC.Prim.~# fsk_a1cl[fsk:1] (CFunEqCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [G] co_a1cp {1}:: F [fsk_a1cl[fsk:1]]
                                  GHC.Prim.~# fsk_a1cl[fsk:1] (CFunEqCan)
doTopReact
  [G] co_a1cp {1}:: F [fsk_a1cl[fsk:1]]
                    GHC.Prim.~# fsk_a1cl[fsk:1] (CFunEqCan)
end stage top-level reactions }
insertInertCan {
  Trying to insert new inert item: [G] co_a1cp {1}:: F [fsk_a1cl[fsk:1]]
                                                     GHC.Prim.~# fsk_a1cl[fsk:1] (CFunEqCan)
addInertCan }
Step 6[l:1,d:1] Kept as inert:
    [G] co_a1cp {1}:: F [fsk_a1cl[fsk:1]] GHC.Prim.~# fsk_a1cl[fsk:1]
End solver pipeline (kept as inert) }
  final_item = [G] co_a1cp {1}:: F [fsk_a1cl[fsk:1]]
                                 GHC.Prim.~# fsk_a1cl[fsk:1] (CFunEqCan)
End solveSimpleGivens }
solveWanteds {
  WC {wc_simple =
        [WD] $d~_a1cg {0}:: a_a1cf[tau:1]
                            ~ [F a_a1cf[tau:1]] (CNonCanonical)}
solveSimpleWanteds {
  {[WD] $d~_a1cg {0}:: a_a1cf[tau:1]
                       ~ [F a_a1cf[tau:1]] (CNonCanonical)}
----------------------------- 
Start solver pipeline {
  tclevel = 1
  work item = [WD] $d~_a1cg {0}:: a_a1cf[tau:1]
                                  ~ [F a_a1cf[tau:1]] (CNonCanonical)
  inerts = {Equalities: [G] co_a1ck {0}:: a_a1cd[sk:1]
                                          GHC.Prim.~# [fsk_a1cl[fsk:1]] (CTyEqCan)
            Type-function equalities = [G] co_a1cp {1}:: F [fsk_a1cl[fsk:1]]
                                                         GHC.Prim.~# fsk_a1cl[fsk:1] (CFunEqCan)
            Dictionaries = [G] $d~_a1cn {0}:: [fsk_a1cl[fsk:1]]
                                              ~ [fsk_a1cl[fsk:1]] (CDictCan)
                           [G] $d~~_a1co {0}:: [fsk_a1cl[fsk:1]]
                                               ~~ [fsk_a1cl[fsk:1]] (CDictCan)
            Unsolved goals = 0}
           Inert fsks = [(fsk_a1cl[fsk:1], F a_a1cd[sk:1])]
  rest of worklist = WL {}
runStage canonicalization {
  workitem   =  [WD] $d~_a1cg {0}:: a_a1cf[tau:1]
                                    ~ [F a_a1cf[tau:1]] (CNonCanonical)
canEvNC:cls ~ [*, a_a1cf[tau:1], [F a_a1cf[tau:1]]]
flatten_args {
  *
  a_a1cf[tau:1]
  [F a_a1cf[tau:1]]
Following filled tyvar a_a1cf[tau:1] = a_a1cd[sk:1]
Unfilled tyvar a_a1cd[sk:1]
Following inert tyvar
  FM_FlattenAll a_a1cd[sk:1] = [fsk_a1cl[fsk:1]]
  [G] co_a1ck {0}:: a_a1cd[sk:1] GHC.Prim.~# [fsk_a1cl[fsk:1]]
Unfilled tyvar fsk_a1cl[fsk:1]
matchFamTcM
  Matching: F a_a1cf[tau:1]
  Match failed
Following filled tyvar a_a1cf[tau:1] = a_a1cd[sk:1]
Unfilled tyvar a_a1cd[sk:1]
Following inert tyvar
  FM_FlattenAll a_a1cd[sk:1] = [fsk_a1cl[fsk:1]]
  [G] co_a1ck {0}:: a_a1cd[sk:1] GHC.Prim.~# [fsk_a1cl[fsk:1]]
Unfilled tyvar fsk_a1cl[fsk:1]
flatten/flat-cache hit
  F [[fsk_a1cl[fsk:1]]]
  fsk_a1cl[fsk:1]
Unfilled tyvar fsk_a1cl[fsk:1]
flatten }
  *
  [fsk_a1cl[fsk:1]]
  [fsk_a1cl[fsk:1]]
newWantedEvVar/cache hit
  [G] $d~_a1cn {0}:: [fsk_a1cl[fsk:1]] ~ [fsk_a1cl[fsk:1]]
addTcEvBind
  a1ch
  [W] $d~_a1cg
    = $d~_a1cn
      `cast` (((~)
                 <*>_N (Sym co_a1ck) ([Sym co_a1cp ; (F (Sym co_a1ck))_N])_N)_R
              :: ([F a_a1cd[sk:1]] ~ [fsk_a1cl[fsk:1]])
                 ~R# (a_a1cd[sk:1] ~ [F a_a1cd[sk:1]]))
canClass
  [WD] $d~_a1cg {0}:: a_a1cf[tau:1] ~ [F a_a1cf[tau:1]]
  [fsk_a1cl[fsk:1]] ~ [fsk_a1cl[fsk:1]]
  Stop(Cached wanted) [WD] $d~_a1cg {0}:: a_a1cf[tau:1]
                                          ~ [F a_a1cf[tau:1]]
end stage canonicalization }
Step 7[l:1,d:0] Cached wanted:
    [WD] $d~_a1cg {0}:: a_a1cf[tau:1] ~ [F a_a1cf[tau:1]]
End solver pipeline (discharged) }
getUnsolvedInerts
   tv eqs = {}
  fun eqs = {}
  others = {}
  implics = {}
Unflattening
  {Funeqs =
   Tv eqs =}
Unflattening 1 {}
Unflattening 2 {}
Unflattening 3 {}
Unflattening done {}
solveSimpleWanteds end }
  iterations = 1
  residual = WC {}
solveWanteds }
  final wc = WC {}
  current evbinds  = {[G] $d~~_a1cj
                        = Data.Type.Equality.$p1~
                            @ * @ a_a1cd[sk:1] @ [F a_a1cd[sk:1]] $d~_a1ce,
                      [G] co_a1ck
                        = GHC.Types.heq_sel
                            @ * @ * @ a_a1cd[sk:1] @ [F a_a1cd[sk:1]] $d~~_a1cj,
                      [G] co_a1cm = CO: <F a_a1cd[sk:1]>_N,
                      [G] $d~_a1cn
                        = $d~_a1ce
                          `cast` (Sub (Sym ((~) <*>_N (Sym co_a1ck) <[fsk_a1cl[fsk:1]]>_N)_N)
                                  :: (a_a1cd[sk:1] ~ [fsk_a1cl[fsk:1]])
                                     ~R# ([F a_a1cd[sk:1]] ~ [fsk_a1cl[fsk:1]])),
                      [G] $d~~_a1co
                        = $d~~_a1cj
                          `cast` (Sub (Sym ((~~)
                                              <*>_N <*>_N (Sym co_a1ck) <[fsk_a1cl[fsk:1]]>_N)_N)
                                  :: (a_a1cd[sk:1] ~~ [fsk_a1cl[fsk:1]])
                                     ~R# ([F a_a1cd[sk:1]] ~~ [fsk_a1cl[fsk:1]])),
                      [G] co_a1cp = CO: (F (Sym co_a1ck))_N ; co_a1cm,
                      [W] $d~_a1cg
                        = $d~_a1cn
                          `cast` (((~)
                                     <*>_N (Sym co_a1ck) ([Sym co_a1cp ; (F (Sym co_a1ck))_N])_N)_R
                                  :: ([F a_a1cd[sk:1]] ~ [fsk_a1cl[fsk:1]])
                                     ~R# (a_a1cd[sk:1] ~ [F a_a1cd[sk:1]]))}
getNoGivenEqs
  No given equalities
  Skols: [a_a1cd[sk:1]]
  Inerts: {Equalities: [G] co_a1ck {0}:: a_a1cd[sk:1]
                                         GHC.Prim.~# [fsk_a1cl[fsk:1]] (CTyEqCan)
           Type-function equalities = [G] co_a1cp {1}:: F [fsk_a1cl[fsk:1]]
                                                        GHC.Prim.~# fsk_a1cl[fsk:1] (CFunEqCan)
           Dictionaries = [G] $d~_a1cn {0}:: [fsk_a1cl[fsk:1]]
                                             ~ [fsk_a1cl[fsk:1]] (CDictCan)
                          [G] $d~~_a1co {0}:: [fsk_a1cl[fsk:1]]
                                              ~~ [fsk_a1cl[fsk:1]] (CDictCan)
           Unsolved goals = 0}
  Insols: {}
unflattenGivens [(fsk_a1cl[fsk:1], F a_a1cd[sk:1])]
writeMetaTyVar fsk_a1cl[fsk:1] :: * := F a_a1cd[sk:1]
zonkSimples done: {}
floatEqualities
  Skols = [a_a1cd[sk:1]]
  Extended skols = [a1cd :-> a_a1cd[sk:1], a1ce :-> $d~_a1ce,
                    a1cg :-> $d~_a1cg, a1cj :-> $d~~_a1cj, a1ck :-> co_a1ck,
                    a1cm :-> co_a1cm, a1cn :-> $d~_a1cn, a1co :-> $d~~_a1co,
                    a1cp :-> co_a1cp]
  Simples = {}
  Eqs = {}
  Floated eqs = {}
solveImplication 2
  {}
  WC {}
setImplicationStatus(all-solved) {
  Implic {
    TcLevel = 1
    Skolems = a_a1cd[sk:1]
    No-eqs = True
    Status = Unsolved
    Given = $d~_a1ce :: a_a1cd[sk:1] ~ [F a_a1cd[sk:1]]
    Wanted = WC {}
    Binds = EvBindsVar<a1ch>
    the type signature for:
      asdf :: forall a. (a ~ [F a]) => a -> Bool }
neededEvVars
  old_needs: []
  seeds3: [a1ck :-> co_a1ck, a1cn :-> $d~_a1cn, a1cp :-> co_a1cp]
  ev_binds: [a1cj :-> [G] $d~~_a1cj
                        = Data.Type.Equality.$p1~
                            @ * @ a_a1cd[sk:1] @ [F a_a1cd[sk:1]] $d~_a1ce,
             a1ck :-> [G] co_a1ck
                        = GHC.Types.heq_sel
                            @ * @ * @ a_a1cd[sk:1] @ [F a_a1cd[sk:1]] $d~~_a1cj,
             a1cm :-> [G] co_a1cm = CO: <F a_a1cd[sk:1]>_N,
             a1cn :-> [G] $d~_a1cn
                        = $d~_a1ce
                          `cast` (Sub (Sym ((~) <*>_N (Sym co_a1ck) <[fsk_a1cl[fsk:1]]>_N)_N)
                                  :: (a_a1cd[sk:1] ~ [fsk_a1cl[fsk:1]])
                                     ~R# ([F a_a1cd[sk:1]] ~ [fsk_a1cl[fsk:1]])),
             a1co :-> [G] $d~~_a1co
                        = $d~~_a1cj
                          `cast` (Sub (Sym ((~~)
                                              <*>_N <*>_N (Sym co_a1ck) <[fsk_a1cl[fsk:1]]>_N)_N)
                                  :: (a_a1cd[sk:1] ~~ [fsk_a1cl[fsk:1]])
                                     ~R# ([F a_a1cd[sk:1]] ~~ [fsk_a1cl[fsk:1]])),
             a1cp :-> [G] co_a1cp = CO: (F (Sym co_a1ck))_N ; co_a1cm,
             a1cg :-> [W] $d~_a1cg
                        = $d~_a1cn
                          `cast` (((~)
                                     <*>_N (Sym co_a1ck) ([Sym co_a1cp ; (F (Sym co_a1ck))_N])_N)_R
                                  :: ([F a_a1cd[sk:1]] ~ [fsk_a1cl[fsk:1]])
                                     ~R# (a_a1cd[sk:1] ~ [F a_a1cd[sk:1]]))]
  live_ev_binds: [a1cj :-> [G] $d~~_a1cj
                             = Data.Type.Equality.$p1~
                                 @ * @ a_a1cd[sk:1] @ [F a_a1cd[sk:1]] $d~_a1ce,
                  a1ck :-> [G] co_a1ck
                             = GHC.Types.heq_sel
                                 @ * @ * @ a_a1cd[sk:1] @ [F a_a1cd[sk:1]] $d~~_a1cj,
                  a1cm :-> [G] co_a1cm = CO: <F a_a1cd[sk:1]>_N,
                  a1cn :-> [G] $d~_a1cn
                             = $d~_a1ce
                               `cast` (Sub (Sym ((~) <*>_N (Sym co_a1ck) <[fsk_a1cl[fsk:1]]>_N)_N)
                                       :: (a_a1cd[sk:1] ~ [fsk_a1cl[fsk:1]])
                                          ~R# ([F a_a1cd[sk:1]] ~ [fsk_a1cl[fsk:1]])),
                  a1cp :-> [G] co_a1cp = CO: (F (Sym co_a1ck))_N ; co_a1cm,
                  a1cg :-> [W] $d~_a1cg
                             = $d~_a1cn
                               `cast` (((~)
                                          <*>_N
                                          (Sym co_a1ck)
                                          ([Sym co_a1cp ; (F (Sym co_a1ck))_N])_N)_R
                                       :: ([F a_a1cd[sk:1]] ~ [fsk_a1cl[fsk:1]])
                                          ~R# (a_a1cd[sk:1] ~ [F a_a1cd[sk:1]]))]
setImplicationStatus(all-solved) }
  discard: False
  new_implic: Implic {
                TcLevel = 1
                Skolems = a_a1cd[sk:1]
                No-eqs = True
                Status = Solved {Dead givens = []}
                Given = $d~_a1ce :: a_a1cd[sk:1] ~ [F a_a1cd[sk:1]]
                Wanted = WC {}
                Binds = EvBindsVar<a1ch>
                the type signature for:
                  asdf :: forall a. (a ~ [F a]) => a -> Bool }
solveImplication end }
  no_given_eqs = True
  floated_eqs = {}
  res_implic = Just Implic {
                      TcLevel = 1
                      Skolems = a_a1cd[sk:1]
                      No-eqs = True
                      Status = Solved {Dead givens = []}
                      Given = $d~_a1ce :: a_a1cd[sk:1] ~ [F a_a1cd[sk:1]]
                      Wanted = WC {}
                      Binds = EvBindsVar<a1ch>
                      the type signature for:
                        asdf :: forall a. (a ~ [F a]) => a -> Bool }
  implication evbinds = {[G] $d~~_a1cj
                           = Data.Type.Equality.$p1~
                               @ * @ a_a1cd[sk:1] @ [F a_a1cd[sk:1]] $d~_a1ce,
                         [G] co_a1ck
                           = GHC.Types.heq_sel
                               @ * @ * @ a_a1cd[sk:1] @ [F a_a1cd[sk:1]] $d~~_a1cj,
                         [G] co_a1cm = CO: <F a_a1cd[sk:1]>_N,
                         [G] $d~_a1cn
                           = $d~_a1ce
                             `cast` (Sub (Sym ((~) <*>_N (Sym co_a1ck) <[fsk_a1cl[fsk:1]]>_N)_N)
                                     :: (a_a1cd[sk:1] ~ [fsk_a1cl[fsk:1]])
                                        ~R# ([F a_a1cd[sk:1]] ~ [fsk_a1cl[fsk:1]])),
                         [G] co_a1cp = CO: (F (Sym co_a1ck))_N ; co_a1cm,
                         [W] $d~_a1cg
                           = $d~_a1cn
                             `cast` (((~)
                                        <*>_N
                                        (Sym co_a1ck)
                                        ([Sym co_a1cp ; (F (Sym co_a1ck))_N])_N)_R
                                     :: ([F a_a1cd[sk:1]] ~ [fsk_a1cl[fsk:1]])
                                        ~R# (a_a1cd[sk:1] ~ [F a_a1cd[sk:1]]))}
  implication tvcs = []
solveNestedImplications end }
  all floated_eqs = {}
  unsolved_implics = {Just Implic {
                             TcLevel = 1
                             Skolems = a_a1cd[sk:1]
                             No-eqs = True
                             Status = Solved {Dead givens = []}
                             Given = $d~_a1ce :: a_a1cd[sk:1] ~ [F a_a1cd[sk:1]]
                             Wanted = WC {}
                             Binds = EvBindsVar<a1ch>
                             the type signature for:
                               asdf :: forall a. (a ~ [F a]) => a -> Bool }}
solveWanteds }
  final wc = WC {wc_impl =
                   Implic {
                     TcLevel = 1
                     Skolems = a_a1cd[sk:1]
                     No-eqs = True
                     Status = Solved {Dead givens = []}
                     Given = $d~_a1ce :: a_a1cd[sk:1] ~ [F a_a1cd[sk:1]]
                     Wanted = WC {}
                     Binds = EvBindsVar<a1ch>
                     the type signature for:
                       asdf :: forall a. (a ~ [F a]) => a -> Bool }}
  current evbinds  = {}
Constraint solver steps = 7
unflattenGivens []
End simplifyAmbiguityCheck }
reportUnsolved(ambig) {
newTcEvBinds unique = a1cq
reportUnsolved warning/error settings:
  type errors: TypeError
  expr holes: HoleError
  type holes: HoleError
  scope holes: HoleError
reportUnsolved (before zonking and tidying)
  WC {wc_impl =
        Implic {
          TcLevel = 1
          Skolems = a_a1cd[sk:1]
          No-eqs = True
          Status = Solved {Dead givens = []}
          Given = $d~_a1ce :: a_a1cd[sk:1] ~ [F a_a1cd[sk:1]]
          Wanted = WC {}
          Binds = EvBindsVar<a1ch>
          the type signature for:
            asdf :: forall a. (a ~ [F a]) => a -> Bool }}
zonkSimples done: {}
zonkSimples done: {}
reportUnsolved (after zonking):
  Free tyvars:
  Tidy env: ([], [])
  Wanted: WC {wc_impl =
                Implic {
                  TcLevel = 1
                  Skolems = a_a1cd[sk:1]
                  No-eqs = True
                  Status = Solved {Dead givens = []}
                  Given = $d~_a1ce :: a_a1cd[sk:1] ~ [F a_a1cd[sk:1]]
                  Wanted = WC {}
                  Binds = EvBindsVar<a1ch>
                  the type signature for:
                    asdf :: forall a. (a ~ [F a]) => a -> Bool }}
reportWanteds
  Simples = {}
  Suppress = False
rw2 []
tryReporters {
  []
  []
tryReporters } []
tryReporters {
  []
  []
tryReporters } []
reportImplic
  Implic {
    TcLevel = 1
    Skolems = a_a1cd[sk:1]
    No-eqs = True
    Status = Solved {Dead givens = []}
    Given = $d~_a1ce :: a_a1cd[sk:1] ~ [F a_a1cd[sk:1]]
    Wanted = WC {}
    Binds = EvBindsVar<a1ch>
    the type signature for:
      asdf :: forall a. (a ~ [F a]) => a -> Bool }
reportWanteds
  Simples = {}
  Suppress = False
rw2 []
tryReporters {
  []
  []
tryReporters } []
tryReporters {
  []
  []
tryReporters } []
reportUnsolved(ambig) }
Done ambiguity check for forall a. (a ~ [F a]) => a -> Bool
checkValidType done forall a. (a ~ [F a]) => a -> Bool :: *
end tcHsSigType } forall a. (a ~ [F a]) => a -> Bool
tcHsSigType { forall b_a10N. b_a10N -> G b_a10N
newAnonMetaTyVar t_a1cr[tau:0]
decideKindGeneralisationPlan
  forall b_a10N. b_a10N -> G b_a10N
  should gen? True
solveLocalEqualities {
newMetaKindVar k_a1cs[tau:1]
env2
  [(b_a10N, Type variable ‘b_a10N’ = b_a10N[sk:1] :: k_a1cs[tau:1])]
tcExtendBinderStack [b_a10N b_a10N[sk:1]]
newAnonMetaTyVar t_a1ct[tau:1]
newAnonMetaTyVar t_a1cu[tau:1]
lk1 b_a10N
checkExpectedKind
  b_a10N
  act_kind: k_a1cs[tau:1]
  act_kind': k_a1cs[tau:1]
  exp_kind: TYPE t_a1ct[tau:1]
u_tys
  tclvl 1
  k_a1cs[tau:1] ~ TYPE t_a1ct[tau:1]
  arising from a type equality k_a1cs[tau:1] ~ TYPE t_a1ct[tau:1]
u_tys
  tclvl 1
  * ~ *
  arising from a kind equality arising from
    k_a1cs[tau:1] ~ TYPE t_a1ct[tau:1]
u_tys
  tclvl 1
  'GHC.Types.LiftedRep ~ 'GHC.Types.LiftedRep
  arising from a kind equality arising from
    k_a1cs[tau:1] ~ TYPE t_a1ct[tau:1]
u_tys yields no coercion
u_tys yields no coercion
writeMetaTyVar k_a1cs[tau:1] :: * := TYPE t_a1ct[tau:1]
u_tys yields no coercion
checkExpectedKind
  k_a1cs[tau:1]
  TYPE t_a1ct[tau:1]
  <TYPE t_a1ct[tau:1]>_N
lk1 G
instantiating tybinders:
instantiateTyN
  * -> *
  1
  [TCvSubst In scope: InScope {} Type env: [] Co env: []]
  * -> *
  * -> *
tcTyVar2b
  G :: * -> *
  * -> *
tcInferApps {
  G
  [b_a10N]
  * -> *
tcInferApps (vis)
  [anon] *
  b_a10N
  *
  [TCvSubst In scope: InScope {} Type env: [] Co env: []]
lk1 b_a10N
checkExpectedKind
  b_a10N
  act_kind: TYPE t_a1ct[tau:1]
  act_kind': TYPE t_a1ct[tau:1]
  exp_kind: *
u_tys
  tclvl 1
  TYPE t_a1ct[tau:1] ~ *
  arising from a type equality TYPE t_a1ct[tau:1] ~ *
u_tys
  tclvl 1
  t_a1ct[tau:1] ~ 'GHC.Types.LiftedRep
  arising from a type equality TYPE t_a1ct[tau:1] ~ *
u_tys
  tclvl 1
  GHC.Types.RuntimeRep ~ GHC.Types.RuntimeRep
  arising from a kind equality arising from
    t_a1ct[tau:1] ~ 'GHC.Types.LiftedRep
u_tys yields no coercion
writeMetaTyVar
  t_a1ct[tau:1] :: GHC.Types.RuntimeRep := 'GHC.Types.LiftedRep
u_tys yields no coercion
u_tys yields no coercion
checkExpectedKind
  TYPE t_a1ct[tau:1]
  *
  <*>_N
tcInferApps (vis 1) *
tcInferApps }
checkExpectedKind
  G b_a10N
  act_kind: *
  act_kind': *
  exp_kind: TYPE t_a1cu[tau:1]
u_tys
  tclvl 1
  * ~ TYPE t_a1cu[tau:1]
  arising from a type equality * ~ TYPE t_a1cu[tau:1]
u_tys
  tclvl 1
  'GHC.Types.LiftedRep ~ t_a1cu[tau:1]
  arising from a type equality * ~ TYPE t_a1cu[tau:1]
u_tys
  tclvl 1
  GHC.Types.RuntimeRep ~ GHC.Types.RuntimeRep
  arising from a kind equality arising from
    t_a1cu[tau:1] ~ 'GHC.Types.LiftedRep
u_tys yields no coercion
writeMetaTyVar
  t_a1cu[tau:1] :: GHC.Types.RuntimeRep := 'GHC.Types.LiftedRep
u_tys yields no coercion
u_tys yields no coercion
checkExpectedKind
  *
  TYPE t_a1cu[tau:1]
  <*>_N
checkExpectedKind
  b_a10N -> G b_a10N
  act_kind: *
  act_kind': *
  exp_kind: TYPE t_a1cr[tau:0]
u_tys
  tclvl 1
  * ~ TYPE t_a1cr[tau:0]
  arising from a type equality * ~ TYPE t_a1cr[tau:0]
u_tys
  tclvl 1
  'GHC.Types.LiftedRep ~ t_a1cr[tau:0]
  arising from a type equality * ~ TYPE t_a1cr[tau:0]
New coercion hole: co_a1cv
utype_defer
  'GHC.Types.LiftedRep
  t_a1cr[tau:0]
  arising from a type equality * ~ TYPE t_a1cr[tau:0]
  In the type signature: g :: forall b_a10N. b_a10N -> G b_a10N
utype_defer2 {co_a1cv}
u_tys yields coercion: {co_a1cv}
u_tys yields coercion: (TYPE {co_a1cv})_N
checkExpectedKind
  *
  TYPE t_a1cr[tau:0]
  (TYPE {co_a1cv})_N
newNoTcEvBinds unique = a1cw
tcExplicitTKBndrs
  Hs vars: [b_a10N]
  tvs: (b_a10N[sk:1] :: k_a1cs[tau:1])
solveLocalEqualities: running solver {
  WC {wc_impl =
        Implic {
          TcLevel = 1
          Skolems = (b_a10N[sk:1] :: k_a1cs[tau:1])
          No-eqs = True
          Status = Unsolved
          Given =
          Wanted =
            WC {wc_simple =
                  [WD] hole{co_a1cv} {0}:: 'GHC.Types.LiftedRep
                                           GHC.Prim.~# t_a1cr[tau:0] (CNonCanonical)}
          Binds = NoEvBindsVar<a1cw>
          ‘forall b_a10N. b_a10N -> G b_a10N’ }}
newNoTcEvBinds unique = a1cx
solveWanteds {
  WC {wc_impl =
        Implic {
          TcLevel = 1
          Skolems = (b_a10N[sk:1] :: k_a1cs[tau:1])
          No-eqs = True
          Status = Unsolved
          Given =
          Wanted =
            WC {wc_simple =
                  [WD] hole{co_a1cv} {0}:: 'GHC.Types.LiftedRep
                                           GHC.Prim.~# t_a1cr[tau:0] (CNonCanonical)}
          Binds = NoEvBindsVar<a1cw>
          ‘forall b_a10N. b_a10N -> G b_a10N’ }}
solveSimpleWanteds { {}
solveSimpleWanteds end }
  iterations = 1
  residual = WC {}
solveNestedImplications starting {
solveImplication {
  Implic {
    TcLevel = 1
    Skolems = (b_a10N[sk:1] :: k_a1cs[tau:1])
    No-eqs = True
    Status = Unsolved
    Given =
    Wanted =
      WC {wc_simple =
            [WD] hole{co_a1cv} {0}:: 'GHC.Types.LiftedRep
                                     GHC.Prim.~# t_a1cr[tau:0] (CNonCanonical)}
    Binds = NoEvBindsVar<a1cw>
    ‘forall b_a10N. b_a10N -> G b_a10N’ }
  Inerts {Unsolved goals = 0}
         Inert fsks = []
solveWanteds {
  WC {wc_simple =
        [WD] hole{co_a1cv} {0}:: 'GHC.Types.LiftedRep
                                 GHC.Prim.~# t_a1cr[tau:0] (CNonCanonical)}
solveSimpleWanteds {
  {[WD] hole{co_a1cv} {0}:: 'GHC.Types.LiftedRep
                            GHC.Prim.~# t_a1cr[tau:0] (CNonCanonical)}
----------------------------- 
Start solver pipeline {
  tclevel = 1
  work item = [WD] hole{co_a1cv} {0}:: 'GHC.Types.LiftedRep
                                       GHC.Prim.~# t_a1cr[tau:0] (CNonCanonical)
  inerts = {Unsolved goals = 0}
           Inert fsks = []
  rest of worklist = WL {}
runStage canonicalization {
  workitem   =  [WD] hole{co_a1cv} {0}:: 'GHC.Types.LiftedRep
                                         GHC.Prim.~# t_a1cr[tau:0] (CNonCanonical)
canEvNC:eq
  'GHC.Types.LiftedRep
  t_a1cr[tau:0]
can_eq_nc
  False
  [WD] hole{co_a1cv} {0}:: 'GHC.Types.LiftedRep
                           GHC.Prim.~# t_a1cr[tau:0]
  nominal equality
  'GHC.Types.LiftedRep
  'GHC.Types.LiftedRep
  t_a1cr[tau:0]
  t_a1cr[tau:0]
flatten { FM_FlattenAll 'GHC.Types.LiftedRep
flatten } 'GHC.Types.LiftedRep
flatten { FM_FlattenAll t_a1cr[tau:0]
Unfilled tyvar t_a1cr[tau:0]
flatten } t_a1cr[tau:0]
New coercion hole: co_a1cy
Emitting new coercion hole
  {co_a1cy} :: t_a1cr[tau:0] GHC.Prim.~# 'GHC.Types.LiftedRep
Filling coercion hole co_a1cv := Sym {co_a1cy}
rewriteEqEvidence
  [WD] hole{co_a1cv} {0}:: 'GHC.Types.LiftedRep
                           GHC.Prim.~# t_a1cr[tau:0]
  t_a1cr[tau:0]
  'GHC.Types.LiftedRep
  Sym {co_a1cy}
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] hole{co_a1cy} {1}:: t_a1cr[tau:0]
                                         GHC.Prim.~# 'GHC.Types.LiftedRep (CTyEqCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [WD] hole{co_a1cy} {1}:: t_a1cr[tau:0]
                                         GHC.Prim.~# 'GHC.Types.LiftedRep (CTyEqCan)
doTopReact
  [WD] hole{co_a1cy} {1}:: t_a1cr[tau:0]
                           GHC.Prim.~# 'GHC.Types.LiftedRep (CTyEqCan)
end stage top-level reactions }
insertInertCan {
  Trying to insert new inert item: [WD] hole{co_a1cy} {1}:: t_a1cr[tau:0]
                                                            GHC.Prim.~# 'GHC.Types.LiftedRep (CTyEqCan)
addInertCan }
Step 1[l:1,d:1] Kept as inert:
    [WD] hole{co_a1cy} {1}:: t_a1cr[tau:0]
                             GHC.Prim.~# 'GHC.Types.LiftedRep
End solver pipeline (kept as inert) }
  final_item = [WD] hole{co_a1cy} {1}:: t_a1cr[tau:0]
                                        GHC.Prim.~# 'GHC.Types.LiftedRep (CTyEqCan)
getUnsolvedInerts
   tv eqs = {[WD] hole{co_a1cy} {1}:: t_a1cr[tau:0]
                                      GHC.Prim.~# 'GHC.Types.LiftedRep (CTyEqCan)}
  fun eqs = {}
  others = {}
  implics = {}
Unflattening
  {Funeqs =
   Tv eqs = [WD] hole{co_a1cy} {1}:: t_a1cr[tau:0]
                                     GHC.Prim.~# 'GHC.Types.LiftedRep (CTyEqCan)}
Unflattening 1 {}
Unflattening 2
  {[WD] hole{co_a1cy} {1}:: t_a1cr[tau:0]
                            GHC.Prim.~# 'GHC.Types.LiftedRep (CTyEqCan)}
Unflattening 3 {}
Unflattening done
  {[WD] hole{co_a1cy} {1}:: t_a1cr[tau:0]
                            GHC.Prim.~# 'GHC.Types.LiftedRep (CNonCanonical)}
solveSimpleWanteds end }
  iterations = 1
  residual = WC {wc_simple =
                   [WD] hole{co_a1cy} {1}:: t_a1cr[tau:0]
                                            GHC.Prim.~# 'GHC.Types.LiftedRep (CNonCanonical)}
solveWanteds }
  final wc = WC {wc_simple =
                   [WD] hole{co_a1cy} {1}:: t_a1cr[tau:0]
                                            GHC.Prim.~# 'GHC.Types.LiftedRep (CNonCanonical)}
  current evbinds  = {}
getNoGivenEqs
  No given equalities
  Skols: [b_a10N[sk:1]]
  Inerts: {Unsolved goals = 0}
  Insols: {}
unflattenGivens []
zonkSimples done:
  {[WD] hole{co_a1cy} {1}:: t_a1cr[tau:0]
                            GHC.Prim.~# 'GHC.Types.LiftedRep (CNonCanonical)}
floatEqualities
  Skols = [b_a10N[sk:1]]
  Extended skols = [a10N :-> b_a10N[sk:1]]
  Simples = {[WD] hole{co_a1cy} {1}:: t_a1cr[tau:0]
                                      GHC.Prim.~# 'GHC.Types.LiftedRep (CNonCanonical)}
  Eqs = {[WD] hole{co_a1cy} {1}:: t_a1cr[tau:0]
                                  GHC.Prim.~# 'GHC.Types.LiftedRep (CNonCanonical)}
  Floated eqs = {[WD] hole{co_a1cy} {1}:: t_a1cr[tau:0]
                                          GHC.Prim.~# 'GHC.Types.LiftedRep (CNonCanonical)}
solveImplication 2
  {}
  WC {}
setImplicationStatus(all-solved) {
  Implic {
    TcLevel = 1
    Skolems = (b_a10N[sk:1] :: k_a1cs[tau:1])
    No-eqs = True
    Status = Unsolved
    Given =
    Wanted = WC {}
    Binds = NoEvBindsVar<a1cw>
    ‘forall b_a10N. b_a10N -> G b_a10N’ }
neededEvVars
  old_needs: []
  seeds3: [a1cy :-> co_a1cy]
  ev_binds: []
  live_ev_binds: []
setImplicationStatus(all-solved) }
  discard: False
  new_implic: Implic {
                TcLevel = 1
                Skolems = (b_a10N[sk:1] :: k_a1cs[tau:1])
                No-eqs = True
                Status = Solved {Dead givens = []}
                Given =
                Wanted = WC {}
                Binds = NoEvBindsVar<a1cw>
                ‘forall b_a10N. b_a10N -> G b_a10N’ }
solveImplication end }
  no_given_eqs = True
  floated_eqs = {[WD] hole{co_a1cy} {1}:: t_a1cr[tau:0]
                                          GHC.Prim.~# 'GHC.Types.LiftedRep (CNonCanonical)}
  res_implic = Just Implic {
                      TcLevel = 1
                      Skolems = (b_a10N[sk:1] :: k_a1cs[tau:1])
                      No-eqs = True
                      Status = Solved {Dead givens = []}
                      Given =
                      Wanted = WC {}
                      Binds = NoEvBindsVar<a1cw>
                      ‘forall b_a10N. b_a10N -> G b_a10N’ }
  implication evbinds = {}
  implication tvcs = [a1cy :-> co_a1cy]
solveNestedImplications end }
  all floated_eqs = {[WD] hole{co_a1cy} {1}:: t_a1cr[tau:0]
                                              GHC.Prim.~# 'GHC.Types.LiftedRep (CNonCanonical)}
  unsolved_implics = {Just Implic {
                             TcLevel = 1
                             Skolems = (b_a10N[sk:1] :: k_a1cs[tau:1])
                             No-eqs = True
                             Status = Solved {Dead givens = []}
                             Given =
                             Wanted = WC {}
                             Binds = NoEvBindsVar<a1cw>
                             ‘forall b_a10N. b_a10N -> G b_a10N’ }}
simpl_loop iteration=0 (no new given superclasses = True, 1 simples to solve)
simpl_loop: wc =
  WC {wc_simple =
        [WD] hole{co_a1cy} {1}:: t_a1cr[tau:0]
                                 GHC.Prim.~# 'GHC.Types.LiftedRep (CNonCanonical)
      wc_impl =
        Implic {
          TcLevel = 1
          Skolems = (b_a10N[sk:1] :: k_a1cs[tau:1])
          No-eqs = True
          Status = Solved {Dead givens = []}
          Given =
          Wanted = WC {}
          Binds = NoEvBindsVar<a1cw>
          ‘forall b_a10N. b_a10N -> G b_a10N’ }}
solveSimpleWanteds {
  {[WD] hole{co_a1cy} {1}:: t_a1cr[tau:0]
                            GHC.Prim.~# 'GHC.Types.LiftedRep (CNonCanonical)}
----------------------------- 
Start solver pipeline {
  tclevel = 0
  work item = [WD] hole{co_a1cy} {1}:: t_a1cr[tau:0]
                                       GHC.Prim.~# 'GHC.Types.LiftedRep (CNonCanonical)
  inerts = {Unsolved goals = 0}
           Inert fsks = []
  rest of worklist = WL {}
runStage canonicalization {
  workitem   =  [WD] hole{co_a1cy} {1}:: t_a1cr[tau:0]
                                         GHC.Prim.~# 'GHC.Types.LiftedRep (CNonCanonical)
canEvNC:eq
  t_a1cr[tau:0]
  'GHC.Types.LiftedRep
can_eq_nc
  False
  [WD] hole{co_a1cy} {1}:: t_a1cr[tau:0]
                           GHC.Prim.~# 'GHC.Types.LiftedRep
  nominal equality
  t_a1cr[tau:0]
  t_a1cr[tau:0]
  'GHC.Types.LiftedRep
  'GHC.Types.LiftedRep
flatten { FM_FlattenAll t_a1cr[tau:0]
Unfilled tyvar t_a1cr[tau:0]
flatten } t_a1cr[tau:0]
flatten { FM_FlattenAll 'GHC.Types.LiftedRep
flatten } 'GHC.Types.LiftedRep
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] hole{co_a1cy} {1}:: t_a1cr[tau:0]
                                         GHC.Prim.~# 'GHC.Types.LiftedRep (CTyEqCan)
Sneaky unification:
  Unifies: t_a1cr[tau:0] := 'GHC.Types.LiftedRep
  Coercion: t_a1cr[tau:0] ~ 'GHC.Types.LiftedRep
  Left Kind is: GHC.Types.RuntimeRep
  Right Kind is: GHC.Types.RuntimeRep
unifyTyVar t_a1cr[tau:0] := 'GHC.Types.LiftedRep
writeMetaTyVar
  t_a1cr[tau:0] :: GHC.Types.RuntimeRep := 'GHC.Types.LiftedRep
Filling coercion hole co_a1cy := <'GHC.Types.LiftedRep>_N
end stage interact with inerts }
Step 2[l:0,d:1] Solved by unification:
    [WD] hole{co_a1cy} {1}:: t_a1cr[tau:0]
                             GHC.Prim.~# 'GHC.Types.LiftedRep
End solver pipeline (discharged) }
getUnsolvedInerts
   tv eqs = {}
  fun eqs = {}
  others = {}
  implics = {}
Unflattening
  {Funeqs =
   Tv eqs =}
Unflattening 1 {}
Unflattening 2 {}
Unflattening 3 {}
Unflattening done {}
solveSimpleWanteds end }
  iterations = 1
  residual = WC {}
solveNestedImplications starting {
solveNestedImplications end }
  all floated_eqs = {}
  unsolved_implics = {Just Implic {
                             TcLevel = 1
                             Skolems = (b_a10N[sk:1] :: k_a1cs[tau:1])
                             No-eqs = True
                             Status = Solved {Dead givens = []}
                             Given =
                             Wanted = WC {}
                             Binds = NoEvBindsVar<a1cw>
                             ‘forall b_a10N. b_a10N -> G b_a10N’ }}
solveWanteds }
  final wc = WC {wc_impl =
                   Implic {
                     TcLevel = 1
                     Skolems = (b_a10N[sk:1] :: k_a1cs[tau:1])
                     No-eqs = True
                     Status = Solved {Dead givens = []}
                     Given =
                     Wanted = WC {}
                     Binds = NoEvBindsVar<a1cw>
                     ‘forall b_a10N. b_a10N -> G b_a10N’ }}
  current evbinds  = {}
Constraint solver steps = 2
unflattenGivens []
solveLocalEqualities: running solver }
  WC {wc_impl =
        Implic {
          TcLevel = 1
          Skolems = (b_a10N[sk:1] :: k_a1cs[tau:1])
          No-eqs = True
          Status = Solved {Dead givens = []}
          Given =
          Wanted = WC {}
          Binds = NoEvBindsVar<a1cw>
          ‘forall b_a10N. b_a10N -> G b_a10N’ }}
solveLocalEqualities end }
solveEqualities {
  wanted =  WC {wc_impl =
                  Implic {
                    TcLevel = 1
                    Skolems = (b_a10N[sk:1] :: k_a1cs[tau:1])
                    No-eqs = True
                    Status = Solved {Dead givens = []}
                    Given =
                    Wanted = WC {}
                    Binds = NoEvBindsVar<a1cw>
                    ‘forall b_a10N. b_a10N -> G b_a10N’ }}
newNoTcEvBinds unique = a1cz
solveWanteds {
  WC {wc_impl =
        Implic {
          TcLevel = 1
          Skolems = (b_a10N[sk:1] :: k_a1cs[tau:1])
          No-eqs = True
          Status = Solved {Dead givens = []}
          Given =
          Wanted = WC {}
          Binds = NoEvBindsVar<a1cw>
          ‘forall b_a10N. b_a10N -> G b_a10N’ }}
solveSimpleWanteds { {}
solveSimpleWanteds end }
  iterations = 1
  residual = WC {}
solveNestedImplications starting {
solveNestedImplications end }
  all floated_eqs = {}
  unsolved_implics = {Just Implic {
                             TcLevel = 1
                             Skolems = (b_a10N[sk:1] :: k_a1cs[tau:1])
                             No-eqs = True
                             Status = Solved {Dead givens = []}
                             Given =
                             Wanted = WC {}
                             Binds = NoEvBindsVar<a1cw>
                             ‘forall b_a10N. b_a10N -> G b_a10N’ }}
solveWanteds }
  final wc = WC {wc_impl =
                   Implic {
                     TcLevel = 1
                     Skolems = (b_a10N[sk:1] :: k_a1cs[tau:1])
                     No-eqs = True
                     Status = Solved {Dead givens = []}
                     Given =
                     Wanted = WC {}
                     Binds = NoEvBindsVar<a1cw>
                     ‘forall b_a10N. b_a10N -> G b_a10N’ }}
  current evbinds  = {}
zonkSimples done: {}
zonkSimples done: {}
applyDefaultingRules {
  wanteds = WC {wc_impl =
                  Implic {
                    TcLevel = 1
                    Skolems = b_a10N[sk:1]
                    No-eqs = True
                    Status = Solved {Dead givens = []}
                    Given =
                    Wanted = WC {}
                    Binds = NoEvBindsVar<a1cw>
                    ‘forall b_a10N. b_a10N -> G b_a10N’ }}
  groups  = []
  info    = ([Integer, Double], (False, False))
applyDefaultingRules } []
unflattenGivens []
End solveEqualities }
reportAllUnsolved {
newNoTcEvBinds unique = a1cA
reportUnsolved warning/error settings:
  type errors: TypeError
  expr holes: HoleError
  type holes: HoleError
  scope holes: HoleError
reportUnsolved (before zonking and tidying)
  WC {wc_impl =
        Implic {
          TcLevel = 1
          Skolems = (b_a10N[sk:1] :: k_a1cs[tau:1])
          No-eqs = True
          Status = Solved {Dead givens = []}
          Given =
          Wanted = WC {}
          Binds = NoEvBindsVar<a1cw>
          ‘forall b_a10N. b_a10N -> G b_a10N’ }}
zonkSimples done: {}
zonkSimples done: {}
reportUnsolved (after zonking):
  Free tyvars:
  Tidy env: ([], [])
  Wanted: WC {wc_impl =
                Implic {
                  TcLevel = 1
                  Skolems = b_a10N[sk:1]
                  No-eqs = True
                  Status = Solved {Dead givens = []}
                  Given =
                  Wanted = WC {}
                  Binds = NoEvBindsVar<a1cw>
                  ‘forall b_a10N. b_a10N -> G b_a10N’ }}
reportWanteds
  Simples = {}
  Suppress = False
rw2 []
tryReporters {
  []
  []
tryReporters } []
tryReporters {
  []
  []
tryReporters } []
reportImplic
  Implic {
    TcLevel = 1
    Skolems = b_a10N[sk:1]
    No-eqs = True
    Status = Solved {Dead givens = []}
    Given =
    Wanted = WC {}
    Binds = NoEvBindsVar<a1cw>
    ‘forall b_a10N. b_a10N -> G b_a10N’ }
reportWanteds
  Simples = {}
  Suppress = False
rw2 []
tryReporters {
  []
  []
tryReporters } []
tryReporters {
  []
  []
tryReporters } []
reportAllUnsolved }
quantifyTyVars
  DV {dv_kvs = [] dv_tvs = []}
  []
quantifyTyVars
  globals: []
  nondep:
  dep:
  dep_kvs'
  nondep_tvs'
checkValidType forall b. b -> G b :: *
check_type
  forall b. b -> G b
  True
Ambiguity check for forall b. b -> G b
tcSubType_NC
  the type signature for ‘g’
  forall b. b -> G b
  forall b. b -> G b
tc_sub_tc_type (general case)
  ty_actual   = forall b. b -> G b
  ty_expected = forall b. b -> G b
tcSkolemise
tc_sub_type_ds
  ty_actual   = forall b. b -> G b
  ty_expected = b_a1cC[sk:1] -> G b_a1cC[sk:1]
cloneAnonMetaTyVar b_a1cD[tau:1]
Instantiating
  all tyvars? True
  origin arising from a type equality forall b. b -> G b
                                      ~
                                      forall b. b -> G b
  type forall @b_a10N[sk:1]. b_a10N[sk:0] -> G b_a10N[sk:0]
  theta []
  leave_bndrs []
  with b_a1cD[tau:1]
  theta: []
tc_sub_type_ds
  ty_actual   = b_a1cD[tau:1] -> G b_a1cD[tau:1]
  ty_expected = b_a1cC[sk:1] -> G b_a1cC[sk:1]
tc_sub_type_ds
  ty_actual   = G b_a1cD[tau:1]
  ty_expected = G b_a1cC[sk:1]
deeply_instantiate final subst
  origin: arising from a type equality forall b. b -> G b
                                       ~
                                       forall b. b -> G b
  type: G b_a1cD[tau:1]
  new type: G b_a1cD[tau:1]
  subst: [TCvSubst
            In scope: InScope {b_a1cD}
            Type env: []
            Co env: []]
u_tys
  tclvl 1
  G b_a1cD[tau:1] ~ G b_a1cC[sk:1]
  arising from a type equality b_a1cD[tau:1] -> G b_a1cD[tau:1]
                               ~
                               b_a1cC[sk:1] -> G b_a1cC[sk:1]
New coercion hole: co_a1cE
utype_defer
  G b_a1cD[tau:1]
  G b_a1cC[sk:1]
  arising from a type equality b_a1cD[tau:1] -> G b_a1cD[tau:1]
                               ~
                               b_a1cC[sk:1] -> G b_a1cC[sk:1]
  In the ambiguity check for ‘g’
  To defer the ambiguity check to use sites, enable AllowAmbiguousTypes
  In the type signature: g :: forall b_a10N. b_a10N -> G b_a10N
utype_defer2 {co_a1cE}
u_tys yields coercion: {co_a1cE}
tc_sub_tc_type (general case)
  ty_actual   = b_a1cC[sk:1]
  ty_expected = b_a1cD[tau:1]
tcSkolemise
tc_sub_type_ds
  ty_actual   = b_a1cC[sk:1]
  ty_expected = b_a1cD[tau:1]
u_tys
  tclvl 1
  b_a1cC[sk:1] ~ b_a1cD[tau:1]
  arising from a type equality b_a1cD[tau:1] -> G b_a1cD[tau:1]
                               ~
                               b_a1cC[sk:1] -> G b_a1cC[sk:1]
u_tys
  tclvl 1
  * ~ *
  arising from a kind equality arising from
    b_a1cD[tau:1] ~ b_a1cC[sk:1]
u_tys
  tclvl 1
  'GHC.Types.LiftedRep ~ 'GHC.Types.LiftedRep
  arising from a kind equality arising from
    b_a1cD[tau:1] ~ b_a1cC[sk:1]
u_tys yields no coercion
u_tys yields no coercion
writeMetaTyVar b_a1cD[tau:1] :: * := b_a1cC[sk:1]
u_tys yields no coercion
newTcEvBinds unique = a1cF
checkConstraints
  1
  [b_a1cC[sk:1]]
simplifyAmbiguityCheck {
  type =  forall b. b -> G b
  wanted =  WC {wc_impl =
                  Implic {
                    TcLevel = 1
                    Skolems = b_a1cC[sk:1]
                    No-eqs = False
                    Status = Unsolved
                    Given =
                    Wanted =
                      WC {wc_simple =
                            [WD] hole{co_a1cE} {0}:: G b_a1cD[tau:1]
                                                     GHC.Prim.~# G b_a1cC[sk:1] (CNonCanonical)}
                    Binds = EvBindsVar<a1cF>
                    the type signature for:
                      g :: forall b. b -> G b }}
newTcEvBinds unique = a1cG
solveWanteds {
  WC {wc_impl =
        Implic {
          TcLevel = 1
          Skolems = b_a1cC[sk:1]
          No-eqs = False
          Status = Unsolved
          Given =
          Wanted =
            WC {wc_simple =
                  [WD] hole{co_a1cE} {0}:: G b_a1cD[tau:1]
                                           GHC.Prim.~# G b_a1cC[sk:1] (CNonCanonical)}
          Binds = EvBindsVar<a1cF>
          the type signature for:
            g :: forall b. b -> G b }}
solveSimpleWanteds { {}
solveSimpleWanteds end }
  iterations = 1
  residual = WC {}
solveNestedImplications starting {
solveImplication {
  Implic {
    TcLevel = 1
    Skolems = b_a1cC[sk:1]
    No-eqs = False
    Status = Unsolved
    Given =
    Wanted =
      WC {wc_simple =
            [WD] hole{co_a1cE} {0}:: G b_a1cD[tau:1]
                                     GHC.Prim.~# G b_a1cC[sk:1] (CNonCanonical)}
    Binds = EvBindsVar<a1cF>
    the type signature for:
      g :: forall b. b -> G b }
  Inerts {Unsolved goals = 0}
         Inert fsks = []
solveWanteds {
  WC {wc_simple =
        [WD] hole{co_a1cE} {0}:: G b_a1cD[tau:1]
                                 GHC.Prim.~# G b_a1cC[sk:1] (CNonCanonical)}
solveSimpleWanteds {
  {[WD] hole{co_a1cE} {0}:: G b_a1cD[tau:1]
                            GHC.Prim.~# G b_a1cC[sk:1] (CNonCanonical)}
----------------------------- 
Start solver pipeline {
  tclevel = 1
  work item = [WD] hole{co_a1cE} {0}:: G b_a1cD[tau:1]
                                       GHC.Prim.~# G b_a1cC[sk:1] (CNonCanonical)
  inerts = {Unsolved goals = 0}
           Inert fsks = []
  rest of worklist = WL {}
runStage canonicalization {
  workitem   =  [WD] hole{co_a1cE} {0}:: G b_a1cD[tau:1]
                                         GHC.Prim.~# G b_a1cC[sk:1] (CNonCanonical)
canEvNC:eq
  G b_a1cD[tau:1]
  G b_a1cC[sk:1]
Following filled tyvar (zonk_eq_types) b_a1cD[tau:1] = b_a1cC[sk:1]
Filling coercion hole co_a1cE := <G b_a1cC[sk:1]>_N
end stage canonicalization }
Step 1[l:1,d:0] Solved by reflexivity:
    [WD] hole{co_a1cE} {0}:: G b_a1cD[tau:1] GHC.Prim.~# G b_a1cC[sk:1]
End solver pipeline (discharged) }
getUnsolvedInerts
   tv eqs = {}
  fun eqs = {}
  others = {}
  implics = {}
Unflattening
  {Funeqs =
   Tv eqs =}
Unflattening 1 {}
Unflattening 2 {}
Unflattening 3 {}
Unflattening done {}
solveSimpleWanteds end }
  iterations = 1
  residual = WC {}
solveWanteds }
  final wc = WC {}
  current evbinds  = {}
getNoGivenEqs
  No given equalities
  Skols: [b_a1cC[sk:1]]
  Inerts: {Unsolved goals = 0}
  Insols: {}
unflattenGivens []
zonkSimples done: {}
floatEqualities
  Skols = [b_a1cC[sk:1]]
  Extended skols = [a1cC :-> b_a1cC[sk:1]]
  Simples = {}
  Eqs = {}
  Floated eqs = {}
solveImplication 2
  {}
  WC {}
setImplicationStatus(all-solved) {
  Implic {
    TcLevel = 1
    Skolems = b_a1cC[sk:1]
    No-eqs = True
    Status = Unsolved
    Given =
    Wanted = WC {}
    Binds = EvBindsVar<a1cF>
    the type signature for:
      g :: forall b. b -> G b }
neededEvVars
  old_needs: []
  seeds3: []
  ev_binds: []
  live_ev_binds: []
setImplicationStatus(all-solved) }
  discard: True
  new_implic: Implic {
                TcLevel = 1
                Skolems = b_a1cC[sk:1]
                No-eqs = True
                Status = Solved {Dead givens = []}
                Given =
                Wanted = WC {}
                Binds = EvBindsVar<a1cF>
                the type signature for:
                  g :: forall b. b -> G b }
solveImplication end }
  no_given_eqs = True
  floated_eqs = {}
  res_implic = Nothing
  implication evbinds = {}
  implication tvcs = []
solveNestedImplications end }
  all floated_eqs = {}
  unsolved_implics = {Nothing}
solveWanteds }
  final wc = WC {}
  current evbinds  = {}
Constraint solver steps = 1
unflattenGivens []
End simplifyAmbiguityCheck }
reportUnsolved(ambig) {
newTcEvBinds unique = a1cH
reportUnsolved(ambig) }
Done ambiguity check for forall b. b -> G b
checkValidType done forall b. b -> G b :: *
end tcHsSigType } forall b. b -> G b
env2
  [(asdf,
    Identifier[asdf::forall a.
                     (a ~ [F a]) =>
                     a -> Bool, TopLevelLet [] True]),
   (g, Identifier[g::forall b. b -> G b, TopLevelLet [] True])]
------------------------------------------------
Bindings for { [g]
Generalisation plan CheckGen g :: forall b. b -> G b
tcPolyCheck
  g
  GHCTest.hs:12:1-23
tcExtendBinderStack [g_a1cJ[<NotTopLevel>]]
env2 [(b_a10N, Type variable ‘b_a10N’ = b_a1cI[sk:1] :: *)]
tcExtendBinderStack [b_a10N b_a1cI[sk:1]]
tcMatchesFun
  g_a1cJ
  Check{b_a1cI[sk:1] -> G b_a1cI[sk:1]}
tcSkolemise
tcBody Check{b_a1cI[sk:1] -> G b_a1cI[sk:1]}
tcInferId undefined :: forall a. GHC.Stack.Types.HasCallStack => a
tcCheckId
  undefined
  forall a. GHC.Stack.Types.HasCallStack => a
  Check{b_a1cI[sk:1] -> G b_a1cI[sk:1]}
tcWrapResult
  Actual:   forall a. GHC.Stack.Types.HasCallStack => a
  Expected: Check{b_a1cI[sk:1] -> G b_a1cI[sk:1]}
tc_sub_type_ds
  ty_actual   = forall a. GHC.Stack.Types.HasCallStack => a
  ty_expected = b_a1cI[sk:1] -> G b_a1cI[sk:1]
cloneAnonMetaTyVar r_a1ek[tau:1]
cloneAnonMetaTyVar a_a1el[tau:1]
instCallConstraints [$dIP_a2f1]
Instantiating
  all tyvars? True
  origin arising from a use of ‘undefined’
  type forall @r_a1cK @a_a1cL. GHC.Stack.Types.HasCallStack => a_a1cL
  theta [GHC.Stack.Types.HasCallStack]
  leave_bndrs []
  with r_a1ek[tau:1]
       a_a1el[tau:1]
  theta: [GHC.Stack.Types.HasCallStack]
tc_sub_type_ds
  ty_actual   = a_a1el[tau:1]
  ty_expected = b_a1cI[sk:1] -> G b_a1cI[sk:1]
u_tys
  tclvl 1
  a_a1el[tau:1] ~ b_a1cI[sk:1] -> G b_a1cI[sk:1]
  arising from a type equality a_a1el[tau:1]
                               ~
                               b_a1cI[sk:1] -> G b_a1cI[sk:1]
New coercion hole: co_a2f2
utype_defer
  a_a1el[tau:1]
  b_a1cI[sk:1] -> G b_a1cI[sk:1]
  arising from a type equality a_a1el[tau:1]
                               ~
                               b_a1cI[sk:1] -> G b_a1cI[sk:1]
  In the expression: undefined
  In an equation for ‘g’: g = undefined
utype_defer2 {co_a2f2}
u_tys yields coercion: {co_a2f2}
newTcEvBinds unique = a2f3
checkConstraints
  1
  [b_a1cI[sk:1]]
tcSpecPrags g []
} End of bindings for
  [g]
  NonRecursive
  g forall b. b -> G b
tcExtendBinderStack [g[<TopLevel>]]
env2 [(g, Identifier[g::forall b. b -> G b, TopLevelLet])]
------------------------------------------------
Bindings for { [asdf]
Generalisation plan
  CheckGen asdf :: forall a. (a ~ [F a]) => a -> Bool
tcPolyCheck
  asdf
  GHCTest.hs:15:1-42
tcExtendBinderStack [asdf_a2f5[<NotTopLevel>]]
env2 [(a_aVM, Type variable ‘a_aVM’ = a_a2f4[sk:1] :: *)]
tcExtendBinderStack [a_aVM a_a2f4[sk:1]]
tcMatchesFun
  asdf_a2f5
  Check{a_a2f4[sk:1] -> Bool}
tcSkolemise
tcPatBndr(not let)
  x_a113
  a_a2f4[sk:1]
tcExtendBinderStack [x_a113[<NotTopLevel>]]
env2 [(x_a113, Identifier[x_a113::a_a2f4[sk:1], NotLetBound])]
tcBody Check{Bool}
tcInferId g :: forall b. b -> G b
cloneAnonMetaTyVar b_a2f7[tau:1]
Instantiating
  all tyvars? True
  origin arising from a use of ‘g’
  type forall @b_a10N[sk:1]. b_a10N[sk:0] -> G b_a10N[sk:0]
  theta []
  leave_bndrs []
  with b_a2f7[tau:1]
  theta: []
tcPolyExprNC Check{b_a2f7[tau:1]}
tcSkolemise
tcInferId x_a113 :: a_a2f4[sk:1]
tcCheckId
  x_a113
  a_a2f4[sk:1]
  Check{b_a2f7[tau:1]}
tcWrapResult
  Actual:   a_a2f4[sk:1]
  Expected: Check{b_a2f7[tau:1]}
tc_sub_type_ds
  ty_actual   = a_a2f4[sk:1]
  ty_expected = b_a2f7[tau:1]
u_tys
  tclvl 1
  a_a2f4[sk:1] ~ b_a2f7[tau:1]
  arising from a type equality a_a2f4[sk:1] ~ b_a2f7[tau:1]
u_tys
  tclvl 1
  * ~ *
  arising from a kind equality arising from
    b_a2f7[tau:1] ~ a_a2f4[sk:1]
u_tys
  tclvl 1
  'GHC.Types.LiftedRep ~ 'GHC.Types.LiftedRep
  arising from a kind equality arising from
    b_a2f7[tau:1] ~ a_a2f4[sk:1]
u_tys yields no coercion
u_tys yields no coercion
writeMetaTyVar b_a2f7[tau:1] :: * := a_a2f4[sk:1]
u_tys yields no coercion
tc_sub_type_ds
  ty_actual   = G b_a2f7[tau:1]
  ty_expected = Bool
deeply_instantiate final subst
  origin: arising from a use of ‘g’
  type: G b_a2f7[tau:1]
  new type: G b_a2f7[tau:1]
  subst: [TCvSubst
            In scope: InScope {b_a2f7}
            Type env: []
            Co env: []]
u_tys
  tclvl 1
  G b_a2f7[tau:1] ~ Bool
  arising from a type equality G b_a2f7[tau:1] ~ Bool
New coercion hole: co_a2f8
utype_defer
  G b_a2f7[tau:1]
  Bool
  arising from a type equality G b_a2f7[tau:1] ~ Bool
  In the expression: g x_a113
  In an equation for ‘asdf’: asdf x_a113 = g x_a113
utype_defer2 {co_a2f8}
u_tys yields coercion: {co_a2f8}
newTcEvBinds unique = a2f9
checkConstraints
  1
  [a_a2f4[sk:1]]
tcSpecPrags asdf []
} End of bindings for
  [asdf]
  NonRecursive
  asdf forall a. (a ~ [F a]) => a -> Bool
tcExtendBinderStack [asdf[<TopLevel>]]
env2
  [(asdf,
    Identifier[asdf::forall a. (a ~ [F a]) => a -> Bool, TopLevelLet])]
------------------------------------------------
Bindings for { [main]
Generalisation plan InferGen True
newOpenInferExpType a2fa True 1
tcExtendBinderStack [main[<NotTopLevel>]]
tcMatchesFun
  main
  Infer{a2fa,1 True}
newOpenInferExpType a2fb True 1
tcBody Infer{a2fb,1 True}
tcInferId undefined :: forall a. GHC.Stack.Types.HasCallStack => a
tcCheckId
  undefined
  forall a. GHC.Stack.Types.HasCallStack => a
  Infer{a2fb,1 True}
tcWrapResult
  Actual:   forall a. GHC.Stack.Types.HasCallStack => a
  Expected: Infer{a2fb,1 True}
cloneAnonMetaTyVar r_a2fc[tau:1]
cloneAnonMetaTyVar a_a2fd[tau:1]
instCallConstraints [$dIP_a2ff]
Instantiating (deeply)
  origin arising from a use of ‘undefined’
  type forall a. GHC.Stack.Types.HasCallStack => a
  with [r_a2fc[tau:1], a_a2fd[tau:1]]
  args: []
  theta: [GHC.Stack.Types.HasCallStack]
  subst: [TCvSubst
            In scope: InScope {r_a2fc a_a2fd}
            Type env: [a1cK :-> r_a2fc[tau:1], a1cL :-> a_a2fd[tau:1]]
            Co env: []]
deeply_instantiate final subst
  origin: arising from a use of ‘undefined’
  type: a_a1cL
  new type: a_a2fd[tau:1]
  subst: [TCvSubst
            In scope: InScope {r_a2fc a_a2fd}
            Type env: [a1cK :-> r_a2fc[tau:1], a1cL :-> a_a2fd[tau:1]]
            Co env: []]
newAnonMetaTyVar t_a2fh[tau:1]
u_tys
  tclvl 1
  TYPE r_a2fc[tau:1] ~ TYPE t_a2fh[tau:1]
  arising from a type equality TYPE r_a2fc[tau:1]
                               ~
                               TYPE t_a2fh[tau:1]
u_tys
  tclvl 1
  r_a2fc[tau:1] ~ t_a2fh[tau:1]
  arising from a type equality TYPE r_a2fc[tau:1]
                               ~
                               TYPE t_a2fh[tau:1]
u_tys
  tclvl 1
  GHC.Types.RuntimeRep ~ GHC.Types.RuntimeRep
  arising from a kind equality arising from
    r_a2fc[tau:1] ~ t_a2fh[tau:1]
u_tys yields no coercion
writeMetaTyVar
  r_a2fc[tau:1] :: GHC.Types.RuntimeRep := t_a2fh[tau:1]
u_tys yields no coercion
u_tys yields no coercion
Filling ExpType a2fb := a_a2fd[tau:1]
tcSubTypeDS_NC
  a type expected by the context
  a_a2fd[tau:1]
  Infer{a2fa,1 True}
deeply_instantiate final subst
  origin: arising from an application
  type: a_a2fd[tau:1]
  new type: a_a2fd[tau:1]
  subst: [TCvSubst
            In scope: InScope {r_a2fc a_a2fd}
            Type env: []
            Co env: []]
newAnonMetaTyVar t_a2fi[tau:1]
u_tys
  tclvl 1
  TYPE r_a2fc[tau:1] ~ TYPE t_a2fi[tau:1]
  arising from a type equality TYPE r_a2fc[tau:1]
                               ~
                               TYPE t_a2fi[tau:1]
u_tys
  tclvl 1
  r_a2fc[tau:1] ~ t_a2fi[tau:1]
  arising from a type equality TYPE r_a2fc[tau:1]
                               ~
                               TYPE t_a2fi[tau:1]
found filled tyvar r_a2fc[tau:1] :-> t_a2fh[tau:1]
u_tys
  tclvl 1
  GHC.Types.RuntimeRep ~ GHC.Types.RuntimeRep
  arising from a kind equality arising from
    t_a2fh[tau:1] ~ t_a2fi[tau:1]
u_tys yields no coercion
writeMetaTyVar
  t_a2fh[tau:1] :: GHC.Types.RuntimeRep := t_a2fi[tau:1]
u_tys yields no coercion
u_tys yields no coercion
Filling ExpType a2fa := a_a2fd[tau:1]
simplifyInfer call
  1
  [(main, a_a2fd[tau:1])]
  WC {wc_simple =
        [WD] $dIP_a2ff {0}:: GHC.Stack.Types.HasCallStack (CNonCanonical)}
simplifyInfer {
  sigs = []
  binds = [(main, a_a2fd[tau:1])]
  rhs_tclvl = 1
  infer_mode = ApplyMR
  (unzonked) wanted = WC {wc_simple =
                            [WD] $dIP_a2ff {0}:: GHC.Stack.Types.HasCallStack (CNonCanonical)}
newTcEvBinds unique = a2fk
solveWanteds {
  WC {wc_simple =
        [WD] $dIP_a2ff {0}:: GHC.Stack.Types.HasCallStack (CNonCanonical)}
solveSimpleWanteds {
  {[WD] $dIP_a2ff {0}:: GHC.Stack.Types.HasCallStack (CNonCanonical)}
----------------------------- 
Start solver pipeline {
  tclevel = 1
  work item = [WD] $dIP_a2ff {0}:: GHC.Stack.Types.HasCallStack (CNonCanonical)
  inerts = {Unsolved goals = 0}
           Inert fsks = []
  rest of worklist = WL {}
runStage canonicalization {
  workitem   =  [WD] $dIP_a2ff {0}:: GHC.Stack.Types.HasCallStack (CNonCanonical)
canEvNC:cls GHC.Classes.IP ["callStack", GHC.Stack.Types.CallStack]
Emitting new wanted
  $dIP_a2fu :: GHC.Stack.Types.HasCallStack
  arising from a use of implicit parameter ‘?callStack’
  at GHCTest.hs:4:8-16
addTcEvBind
  a2fk
  [W] $dIP_a2ff
    = (GHC.Stack.Types.pushCallStack
         (GHC.CString.unpackCString# "undefined"#,
          GHC.Stack.Types.SrcLoc
            (GHC.CString.unpackCString# "main"#)
            (GHC.CString.unpackCString# "Main"#)
            (GHC.CString.unpackCString# "GHCTest.hs"#)
            (GHC.Types.I# 4#)
            (GHC.Types.I# 8#)
            (GHC.Types.I# 4#)
            (GHC.Types.I# 17#))
         ($dIP_a2fu
          `cast` (GHC.Classes.N:IP[0]
                      <"callStack">_N <GHC.Stack.Types.CallStack>_N
                  :: (?callStack::GHC.Stack.Types.CallStack)
                     ~R# GHC.Stack.Types.CallStack)))
      `cast` (Sym (GHC.Classes.N:IP[0]
                       <"callStack">_N <GHC.Stack.Types.CallStack>_N)
              :: GHC.Stack.Types.CallStack
                 ~R# (?callStack::GHC.Stack.Types.CallStack))
flatten_args {
  "callStack"
  GHC.Stack.Types.CallStack
flatten }
  "callStack"
  GHC.Stack.Types.CallStack
canClass
  [WD] $dIP_a2fu {0}:: GHC.Stack.Types.HasCallStack
  ?callStack::GHC.Stack.Types.CallStack
  ContinueWith [WD] $dIP_a2fu {0}:: ?callStack::GHC.Stack.Types.CallStack
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] $dIP_a2fu {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [WD] $dIP_a2fu {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)
doTopReact
  [WD] $dIP_a2fu {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)
matchClassInst pred = ?callStack::GHC.Stack.Types.CallStack {
matchInstEnv
  goal: GHC.Classes.IP ["callStack", GHC.Stack.Types.CallStack]
  matches: []
  unify: []
matchClass not matching ?callStack::GHC.Stack.Types.CallStack
} matchClassInst global result NoInstance
try_fundeps
  [WD] $dIP_a2fu {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)
end stage top-level reactions }
insertInertCan {
  Trying to insert new inert item: [WD] $dIP_a2fu {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)
addInertCan }
Step 1[l:1,d:0] Kept as inert:
    [WD] $dIP_a2fu {0}:: ?callStack::GHC.Stack.Types.CallStack
End solver pipeline (kept as inert) }
  final_item = [WD] $dIP_a2fu {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)
getUnsolvedInerts
   tv eqs = {}
  fun eqs = {}
  others = {[WD] $dIP_a2fu {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)}
  implics = {}
Unflattening
  {Funeqs =
   Tv eqs =}
Unflattening 1 {}
Unflattening 2 {}
Unflattening 3 {}
Unflattening done {}
solveSimpleWanteds end }
  iterations = 1
  residual = WC {wc_simple =
                   [WD] $dIP_a2fu {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)}
solveWanteds }
  final wc = WC {wc_simple =
                   [WD] $dIP_a2fu {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)}
  current evbinds  = {[W] $dIP_a2ff
                        = (GHC.Stack.Types.pushCallStack
                             (GHC.CString.unpackCString# "undefined"#,
                              GHC.Stack.Types.SrcLoc
                                (GHC.CString.unpackCString# "main"#)
                                (GHC.CString.unpackCString# "Main"#)
                                (GHC.CString.unpackCString# "GHCTest.hs"#)
                                (GHC.Types.I# 4#)
                                (GHC.Types.I# 8#)
                                (GHC.Types.I# 4#)
                                (GHC.Types.I# 17#))
                             ($dIP_a2fu
                              `cast` (GHC.Classes.N:IP[0]
                                          <"callStack">_N <GHC.Stack.Types.CallStack>_N
                                      :: (?callStack::GHC.Stack.Types.CallStack)
                                         ~R# GHC.Stack.Types.CallStack)))
                          `cast` (Sym (GHC.Classes.N:IP[0]
                                           <"callStack">_N <GHC.Stack.Types.CallStack>_N)
                                  :: GHC.Stack.Types.CallStack
                                     ~R# (?callStack::GHC.Stack.Types.CallStack))}
Constraint solver steps = 1
unflattenGivens []
zonkSimples done:
  {[WD] $dIP_a2fu {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)}
decideMonoTyVars
  mono_tvs0 = []
  mono_tvs1 = []
  no_quant = [?callStack::GHC.Stack.Types.CallStack]
  maybe_quant = []
  eq_constraints = []
  mono_tvs = []
  co_vars = []
decideMonoTyVars: promotion: []
decideQuantifiedTyVars
  seed_tys = [a_a2fd[tau:1]]
  seed_tcvs = [a2fd :-> a_a2fd[tau:1], a2fi :-> t_a2fi[tau:1]]
  grown_tcvs = [a2fd :-> a_a2fd[tau:1], a2fi :-> t_a2fi[tau:1]]
quantifyTyVars
  DV {dv_kvs = [a2fi :-> t_a2fi[tau:1]]
      dv_tvs = [a2fd :-> a_a2fd[tau:1]]}
  []
Defaulting a RuntimeRep var to LiftedRep t_a2fi[tau:1]
writeMetaTyVar
  t_a2fi[tau:1] :: GHC.Types.RuntimeRep := 'GHC.Types.LiftedRep
Skolemising a_a2fd[tau:1] := a_a2fd[sk:1]
writeMetaTyVar a_a2fd[tau:1] :: TYPE t_a2fi[tau:1] := a_a2fd[sk:1]
quantifyTyVars
  globals: []
  nondep: (a_a2fd[tau:1] :: TYPE t_a2fi[tau:1])
  dep: (t_a2fi[tau:1] :: GHC.Types.RuntimeRep)
  dep_kvs'
  nondep_tvs' a_a2fd[sk:1]
decideQuantification
  infer_mode: ApplyMR
  candidates: []
  psig_theta: []
  mono_tvs: []
  co_vars: []
  qtvs: [a_a2fd[sk:1]]
  theta: []
zonkSimples done:
  {[WD] $dIP_a2fu {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan(psc))}
} simplifyInfer/produced residual implication for quantification
  quant_pred_candidates = [?callStack::GHC.Stack.Types.CallStack]
  psig_theta = []
  bound_theta = []
  qtvs = [a_a2fd[sk:1]]
  definite_error = False
mkInferredPolyId
  main
  [a_a2fd[sk:1]]
  []
  forall a. a
checkValidType forall a. a :: *
check_type
  forall a. a
  True
Ambiguity check for forall a. a
tcSubType_NC
  the inferred type for ‘main’
  forall a. a
  forall a. a
tc_sub_tc_type (general case)
  ty_actual   = forall a. a
  ty_expected = forall a. a
tcSkolemise
tc_sub_type_ds
  ty_actual   = forall a. a
  ty_expected = a_a2fP[sk:1]
cloneAnonMetaTyVar a_a2fQ[tau:1]
Instantiating
  all tyvars? True
  origin arising from a type equality forall a. a ~ forall a. a
  type forall {a_a2fd[sk:1]}. a_a2fd[sk:1]
  theta []
  leave_bndrs []
  with a_a2fQ[tau:1]
  theta: []
tc_sub_type_ds
  ty_actual   = a_a2fQ[tau:1]
  ty_expected = a_a2fP[sk:1]
u_tys
  tclvl 1
  a_a2fQ[tau:1] ~ a_a2fP[sk:1]
  arising from a type equality a_a2fQ[tau:1] ~ a_a2fP[sk:1]
u_tys
  tclvl 1
  * ~ *
  arising from a kind equality arising from
    a_a2fQ[tau:1] ~ a_a2fP[sk:1]
u_tys
  tclvl 1
  'GHC.Types.LiftedRep ~ 'GHC.Types.LiftedRep
  arising from a kind equality arising from
    a_a2fQ[tau:1] ~ a_a2fP[sk:1]
u_tys yields no coercion
u_tys yields no coercion
writeMetaTyVar a_a2fQ[tau:1] :: * := a_a2fP[sk:1]
u_tys yields no coercion
checkConstraints
  1
  [a_a2fP[sk:1]]
simplifyAmbiguityCheck {
  type =  forall a. a
  wanted =  WC {}
newTcEvBinds unique = a2fR
solveWanteds { WC {}
solveSimpleWanteds { {}
solveSimpleWanteds end }
  iterations = 1
  residual = WC {}
solveWanteds }
  final wc = WC {}
  current evbinds  = {}
unflattenGivens []
End simplifyAmbiguityCheck }
reportUnsolved(ambig) {
newTcEvBinds unique = a2fS
reportUnsolved(ambig) }
Done ambiguity check for forall a. a
checkValidType done forall a. a :: *
tcSpecPrags main []
Binding: [(main, forall a. a)]
} End of bindings for
  [main]
  NonRecursive
  main forall a. a
tcExtendBinderStack [main[<TopLevel>]]
env2 [(main, Identifier[main::forall a. a, TopLevelLet])]
complete_matches
  [(NonRecursive, {g = undefined}),
   (NonRecursive, {asdf x_a113 = g x_a113}),
   (NonRecursive, {main = undefined})]
  [asdf :: forall a_aVM. (a_aVM ~ [F a_aVM]) => a_aVM -> Bool,
   g :: forall b_a10N. b_a10N -> G b_a10N]
complete_matches []
tcExtendKindEnvList []
env2 []
complete_matches
  []
  []
complete_matches []
Tc6
Tc7
Tc7a
checkMain found Main main
newAnonMetaTyVar t_a2fX[tau:0]
tcInferId main :: forall a. a
tcCheckId
  main
  forall a. a
  Check{IO t_a2fX[tau:0]}
tcWrapResult
  Actual:   forall a. a
  Expected: Check{IO t_a2fX[tau:0]}
tc_sub_type_ds
  ty_actual   = forall a. a
  ty_expected = IO t_a2fX[tau:0]
cloneAnonMetaTyVar a_a2fY[tau:0]
Instantiating
  all tyvars? True
  origin arising from a use of ‘main’
  type forall {a_a2fd[sk:1]}. a_a2fd[sk:1]
  theta []
  leave_bndrs []
  with a_a2fY[tau:0]
  theta: []
tc_sub_type_ds
  ty_actual   = a_a2fY[tau:0]
  ty_expected = IO t_a2fX[tau:0]
u_tys
  tclvl 0
  a_a2fY[tau:0] ~ IO t_a2fX[tau:0]
  arising from a type equality a_a2fY[tau:0] ~ IO t_a2fX[tau:0]
u_tys
  tclvl 0
  * ~ *
  arising from a kind equality arising from
    a_a2fY[tau:0] ~ IO t_a2fX[tau:0]
u_tys
  tclvl 0
  'GHC.Types.LiftedRep ~ 'GHC.Types.LiftedRep
  arising from a kind equality arising from
    a_a2fY[tau:0] ~ IO t_a2fX[tau:0]
u_tys yields no coercion
u_tys yields no coercion
writeMetaTyVar a_a2fY[tau:0] :: * := IO t_a2fX[tau:0]
u_tys yields no coercion
simplifyTop {
  wanted =  WC {wc_impl =
                  Implic {
                    TcLevel = 1
                    Skolems = b_a1cI[sk:1]
                    No-eqs = False
                    Status = Unsolved
                    Given =
                    Wanted =
                      WC {wc_simple =
                            [WD] $dIP_a2f1 {0}:: GHC.Stack.Types.HasCallStack (CNonCanonical)
                            [WD] hole{co_a2f2} {0}:: a_a1el[tau:1]
                                                     GHC.Prim.~# (b_a1cI[sk:1]
                                                                  -> G b_a1cI[sk:1]) (CNonCanonical)}
                    Binds = EvBindsVar<a2f3>
                    the type signature for:
                      g :: forall b. b -> G b }
                  Implic {
                    TcLevel = 1
                    Skolems = a_a2f4[sk:1]
                    No-eqs = False
                    Status = Unsolved
                    Given = $d~_a2f6 :: a_a2f4[sk:1] ~ [F a_a2f4[sk:1]]
                    Wanted =
                      WC {wc_simple =
                            [WD] hole{co_a2f8} {0}:: G b_a2f7[tau:1]
                                                     GHC.Prim.~# Bool (CNonCanonical)}
                    Binds = EvBindsVar<a2f9>
                    the type signature for:
                      asdf :: forall a. (a ~ [F a]) => a -> Bool }
                  Implic {
                    TcLevel = 1
                    Skolems = a_a2fd[sk:1]
                    No-eqs = False
                    Status = Unsolved
                    Given =
                    Wanted =
                      WC {wc_simple =
                            [WD] $dIP_a2fu {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan(psc))}
                    Binds = EvBindsVar<a2fk>
                    the inferred type of main :: a_a2fd[tau:1] }}
newTcEvBinds unique = a2hg
solveWanteds {
  WC {wc_impl =
        Implic {
          TcLevel = 1
          Skolems = b_a1cI[sk:1]
          No-eqs = False
          Status = Unsolved
          Given =
          Wanted =
            WC {wc_simple =
                  [WD] $dIP_a2f1 {0}:: GHC.Stack.Types.HasCallStack (CNonCanonical)
                  [WD] hole{co_a2f2} {0}:: a_a1el[tau:1]
                                           GHC.Prim.~# (b_a1cI[sk:1]
                                                        -> G b_a1cI[sk:1]) (CNonCanonical)}
          Binds = EvBindsVar<a2f3>
          the type signature for:
            g :: forall b. b -> G b }
        Implic {
          TcLevel = 1
          Skolems = a_a2f4[sk:1]
          No-eqs = False
          Status = Unsolved
          Given = $d~_a2f6 :: a_a2f4[sk:1] ~ [F a_a2f4[sk:1]]
          Wanted =
            WC {wc_simple =
                  [WD] hole{co_a2f8} {0}:: G b_a2f7[tau:1]
                                           GHC.Prim.~# Bool (CNonCanonical)}
          Binds = EvBindsVar<a2f9>
          the type signature for:
            asdf :: forall a. (a ~ [F a]) => a -> Bool }
        Implic {
          TcLevel = 1
          Skolems = a_a2fd[sk:1]
          No-eqs = False
          Status = Unsolved
          Given =
          Wanted =
            WC {wc_simple =
                  [WD] $dIP_a2fu {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan(psc))}
          Binds = EvBindsVar<a2fk>
          the inferred type of main :: a_a2fd[tau:1] }}
solveSimpleWanteds { {}
solveSimpleWanteds end }
  iterations = 1
  residual = WC {}
solveNestedImplications starting {
solveImplication {
  Implic {
    TcLevel = 1
    Skolems = b_a1cI[sk:1]
    No-eqs = False
    Status = Unsolved
    Given =
    Wanted =
      WC {wc_simple =
            [WD] $dIP_a2f1 {0}:: GHC.Stack.Types.HasCallStack (CNonCanonical)
            [WD] hole{co_a2f2} {0}:: a_a1el[tau:1]
                                     GHC.Prim.~# (b_a1cI[sk:1] -> G b_a1cI[sk:1]) (CNonCanonical)}
    Binds = EvBindsVar<a2f3>
    the type signature for:
      g :: forall b. b -> G b }
  Inerts {Unsolved goals = 0}
         Inert fsks = []
solveWanteds {
  WC {wc_simple =
        [WD] $dIP_a2f1 {0}:: GHC.Stack.Types.HasCallStack (CNonCanonical)
        [WD] hole{co_a2f2} {0}:: a_a1el[tau:1]
                                 GHC.Prim.~# (b_a1cI[sk:1] -> G b_a1cI[sk:1]) (CNonCanonical)}
solveSimpleWanteds {
  {[WD] $dIP_a2f1 {0}:: GHC.Stack.Types.HasCallStack (CNonCanonical),
   [WD] hole{co_a2f2} {0}:: a_a1el[tau:1]
                            GHC.Prim.~# (b_a1cI[sk:1] -> G b_a1cI[sk:1]) (CNonCanonical)}
----------------------------- 
Start solver pipeline {
  tclevel = 1
  work item = [WD] hole{co_a2f2} {0}:: a_a1el[tau:1]
                                       GHC.Prim.~# (b_a1cI[sk:1] -> G b_a1cI[sk:1]) (CNonCanonical)
  inerts = {Unsolved goals = 0}
           Inert fsks = []
  rest of worklist = WL {Non-eqs = [WD] $dIP_a2f1 {0}:: GHC.Stack.Types.HasCallStack (CNonCanonical)}
runStage canonicalization {
  workitem   =  [WD] hole{co_a2f2} {0}:: a_a1el[tau:1]
                                         GHC.Prim.~# (b_a1cI[sk:1]
                                                      -> G b_a1cI[sk:1]) (CNonCanonical)
canEvNC:eq
  a_a1el[tau:1]
  b_a1cI[sk:1] -> G b_a1cI[sk:1]
can_eq_nc
  False
  [WD] hole{co_a2f2} {0}:: a_a1el[tau:1]
                           GHC.Prim.~# (b_a1cI[sk:1] -> G b_a1cI[sk:1])
  nominal equality
  a_a1el[tau:1]
  a_a1el[tau:1]
  b_a1cI[sk:1] -> G b_a1cI[sk:1]
  b_a1cI[sk:1] -> G b_a1cI[sk:1]
flatten { FM_FlattenAll a_a1el[tau:1]
Unfilled tyvar a_a1el[tau:1]
flatten } a_a1el[tau:1]
flatten { FM_FlattenAll b_a1cI[sk:1] -> G b_a1cI[sk:1]
Unfilled tyvar b_a1cI[sk:1]
matchFamTcM
  Matching: G b_a1cI[sk:1]
  Match failed
Unfilled tyvar b_a1cI[sk:1]
matchFamTcM
  Matching: G b_a1cI[sk:1]
  Match failed
New coercion hole: co_a2hi
Emitting new coercion hole
  {co_a2hi} :: G b_a1cI[sk:1] GHC.Prim.~# s_a2hh[fmv:1]
extendFlatCache
  G [b_a1cI[sk:1]]
  [WD]
  s_a2hh[fmv:1]
flatten/flat-cache miss
  G [b_a1cI[sk:1]]
  s_a2hh[fmv:1]
  [WD] hole{co_a2hi} {0}:: G b_a1cI[sk:1] GHC.Prim.~# s_a2hh[fmv:1]
flatten } b_a1cI[sk:1] -> s_a2hh[fmv:1]
New coercion hole: co_a2hj
Emitting new coercion hole
  {co_a2hj} :: a_a1el[tau:1]
               GHC.Prim.~# (b_a1cI[sk:1] -> s_a2hh[fmv:1])
Filling coercion hole
  co_a2f2 := {co_a2hj} ; (<b_a1cI[sk:1]>_N ->_N Sym {co_a2hi})
rewriteEqEvidence
  [WD] hole{co_a2f2} {0}:: a_a1el[tau:1]
                           GHC.Prim.~# (b_a1cI[sk:1] -> G b_a1cI[sk:1])
  a_a1el[tau:1]
  b_a1cI[sk:1] -> s_a2hh[fmv:1]
  {co_a2hj} ; (<b_a1cI[sk:1]>_N ->_N Sym {co_a2hi})
flattenKind { [WD] TYPE r_a1ek[tau:1]
Unfilled tyvar r_a1ek[tau:1]
flattenKind }
  TYPE r_a1ek[tau:1]
  <TYPE r_a1ek[tau:1]>_N
flattenKind { [WD] *
flattenKind }
  *
  <*>_N
canEqTyVar tried flattening kinds
  (a_a1el[tau:1] :: TYPE r_a1ek[tau:1])
  ~
  (b_a1cI[sk:1] -> s_a2hh[fmv:1] :: *)
  TYPE r_a1ek[tau:1]
  <TYPE r_a1ek[tau:1]>_N
  *
  <*>_N
Emitting new derived equality
  [D] _ {1}:: TYPE r_a1ek[tau:1] GHC.Prim.~# *
  arising from a kind equality arising from
    a_a1el[tau:1] ~ b_a1cI[sk:1] -> s_a2hh[fmv:1]
  at GHCTest.hs:13:5-13
Hetero equality gives rise to derived kind equality
  [WD] hole{co_a2hj} {1}:: a_a1el[tau:1]
                           GHC.Prim.~# (b_a1cI[sk:1] -> s_a2hh[fmv:1])
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] hole{co_a2hj} {1}:: a_a1el[tau:1]
                                         GHC.Prim.~# (b_a1cI[sk:1]
                                                      -> s_a2hh[fmv:1]) (CIrredCan(sol))
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [WD] hole{co_a2hj} {1}:: a_a1el[tau:1]
                                         GHC.Prim.~# (b_a1cI[sk:1]
                                                      -> s_a2hh[fmv:1]) (CIrredCan(sol))
doTopReact
  [WD] hole{co_a2hj} {1}:: a_a1el[tau:1]
                           GHC.Prim.~# (b_a1cI[sk:1] -> s_a2hh[fmv:1]) (CIrredCan(sol))
end stage top-level reactions }
insertInertCan {
  Trying to insert new inert item: [WD] hole{co_a2hj} {1}:: a_a1el[tau:1]
                                                            GHC.Prim.~# (b_a1cI[sk:1]
                                                                         -> s_a2hh[fmv:1]) (CIrredCan(sol))
addInertCan }
Step 1[l:1,d:1] Kept as inert:
    [WD] hole{co_a2hj} {1}:: a_a1el[tau:1]
                             GHC.Prim.~# (b_a1cI[sk:1] -> s_a2hh[fmv:1])
End solver pipeline (kept as inert) }
  final_item = [WD] hole{co_a2hj} {1}:: a_a1el[tau:1]
                                        GHC.Prim.~# (b_a1cI[sk:1] -> s_a2hh[fmv:1]) (CIrredCan(sol))
----------------------------- 
Start solver pipeline {
  tclevel = 1
  work item = [D] _ {1}:: TYPE r_a1ek[tau:1]
                          GHC.Prim.~# * (CNonCanonical)
  inerts = {Irreds = [WD] hole{co_a2hj} {1}:: a_a1el[tau:1]
                                              GHC.Prim.~# (b_a1cI[sk:1]
                                                           -> s_a2hh[fmv:1]) (CIrredCan(sol))
            Unsolved goals = 1}
           Inert fsks = []
  rest of worklist = WL {Funeqs = [WD] hole{co_a2hi} {0}:: G b_a1cI[sk:1]
                                                           GHC.Prim.~# s_a2hh[fmv:1] (CFunEqCan)
                         Non-eqs = [WD] $dIP_a2f1 {0}:: GHC.Stack.Types.HasCallStack (CNonCanonical)}
runStage canonicalization {
  workitem   =  [D] _ {1}:: TYPE r_a1ek[tau:1]
                            GHC.Prim.~# * (CNonCanonical)
canEvNC:eq
  TYPE r_a1ek[tau:1]
  *
can_eq_nc
  False
  [D] _ {1}:: TYPE r_a1ek[tau:1] GHC.Prim.~# *
  nominal equality
  TYPE r_a1ek[tau:1]
  TYPE r_a1ek[tau:1]
  *
  *
canTyConApp
  [D] _ {1}:: TYPE r_a1ek[tau:1] GHC.Prim.~# *
  nominal equality
  TYPE
  [r_a1ek[tau:1]]
  ['GHC.Types.LiftedRep]
Emitting new derived equality
  [D] _ {1}:: r_a1ek[tau:1] GHC.Prim.~# 'GHC.Types.LiftedRep
  arising from a kind equality arising from
    a_a1el[tau:1] ~ b_a1cI[sk:1] -> s_a2hh[fmv:1]
  at GHCTest.hs:13:5-13
end stage canonicalization }
Step 2[l:1,d:1] Decomposed TyConApp:
    [D] _ {1}:: TYPE r_a1ek[tau:1] GHC.Prim.~# *
End solver pipeline (discharged) }
----------------------------- 
Start solver pipeline {
  tclevel = 1
  work item = [D] _ {1}:: r_a1ek[tau:1]
                          GHC.Prim.~# 'GHC.Types.LiftedRep (CNonCanonical)
  inerts = {Irreds = [WD] hole{co_a2hj} {1}:: a_a1el[tau:1]
                                              GHC.Prim.~# (b_a1cI[sk:1]
                                                           -> s_a2hh[fmv:1]) (CIrredCan(sol))
            Unsolved goals = 1}
           Inert fsks = []
  rest of worklist = WL {Funeqs = [WD] hole{co_a2hi} {0}:: G b_a1cI[sk:1]
                                                           GHC.Prim.~# s_a2hh[fmv:1] (CFunEqCan)
                         Non-eqs = [WD] $dIP_a2f1 {0}:: GHC.Stack.Types.HasCallStack (CNonCanonical)}
runStage canonicalization {
  workitem   =  [D] _ {1}:: r_a1ek[tau:1]
                            GHC.Prim.~# 'GHC.Types.LiftedRep (CNonCanonical)
canEvNC:eq
  r_a1ek[tau:1]
  'GHC.Types.LiftedRep
can_eq_nc
  False
  [D] _ {1}:: r_a1ek[tau:1] GHC.Prim.~# 'GHC.Types.LiftedRep
  nominal equality
  r_a1ek[tau:1]
  r_a1ek[tau:1]
  'GHC.Types.LiftedRep
  'GHC.Types.LiftedRep
flatten { FM_FlattenAll r_a1ek[tau:1]
Unfilled tyvar r_a1ek[tau:1]
flatten } r_a1ek[tau:1]
flatten { FM_FlattenAll 'GHC.Types.LiftedRep
flatten } 'GHC.Types.LiftedRep
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [D] _ {1}:: r_a1ek[tau:1]
                            GHC.Prim.~# 'GHC.Types.LiftedRep (CTyEqCan)
Sneaky unification:
  Unifies: r_a1ek[tau:1] := 'GHC.Types.LiftedRep
  Coercion: r_a1ek[tau:1] ~ 'GHC.Types.LiftedRep
  Left Kind is: GHC.Types.RuntimeRep
  Right Kind is: GHC.Types.RuntimeRep
unifyTyVar r_a1ek[tau:1] := 'GHC.Types.LiftedRep
writeMetaTyVar
  r_a1ek[tau:1] :: GHC.Types.RuntimeRep := 'GHC.Types.LiftedRep
Kick out, tv = r_a1ek[tau:1]
  n-kicked = 1
  kicked_out = WL {Eqs = [WD] hole{co_a2hj} {1}:: a_a1el[tau:1]
                                                  GHC.Prim.~# (b_a1cI[sk:1]
                                                               -> s_a2hh[fmv:1]) (CIrredCan(sol))}
  Residual inerts = {Unsolved goals = 0}
end stage interact with inerts }
Step 3[l:1,d:1] Solved by unification (1 kicked out):
    [D] _ {1}:: r_a1ek[tau:1] GHC.Prim.~# 'GHC.Types.LiftedRep
End solver pipeline (discharged) }
----------------------------- 
Start solver pipeline {
  tclevel = 1
  work item = [WD] hole{co_a2hj} {1}:: a_a1el[tau:1]
                                       GHC.Prim.~# (b_a1cI[sk:1] -> s_a2hh[fmv:1]) (CIrredCan(sol))
  inerts = {Unsolved goals = 0}
           Inert fsks = []
  rest of worklist = WL {Funeqs = [WD] hole{co_a2hi} {0}:: G b_a1cI[sk:1]
                                                           GHC.Prim.~# s_a2hh[fmv:1] (CFunEqCan)
                         Non-eqs = [WD] $dIP_a2f1 {0}:: GHC.Stack.Types.HasCallStack (CNonCanonical)}
runStage canonicalization {
  workitem   =  [WD] hole{co_a2hj} {1}:: a_a1el[tau:1]
                                         GHC.Prim.~# (b_a1cI[sk:1]
                                                      -> s_a2hh[fmv:1]) (CIrredCan(sol))
can_eq_nc
  False
  [WD] hole{co_a2hj} {1}:: a_a1el[tau:1]
                           GHC.Prim.~# (b_a1cI[sk:1] -> s_a2hh[fmv:1])
  nominal equality
  a_a1el[tau:1]
  a_a1el[tau:1]
  b_a1cI[sk:1] -> s_a2hh[fmv:1]
  b_a1cI[sk:1] -> s_a2hh[fmv:1]
flatten { FM_FlattenAll a_a1el[tau:1]
Unfilled tyvar a_a1el[tau:1]
flatten } a_a1el[tau:1]
flatten { FM_FlattenAll b_a1cI[sk:1] -> s_a2hh[fmv:1]
Unfilled tyvar b_a1cI[sk:1]
Unfilled tyvar s_a2hh[fmv:1]
flatten } b_a1cI[sk:1] -> s_a2hh[fmv:1]
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] hole{co_a2hj} {1}:: a_a1el[tau:1]
                                         GHC.Prim.~# (b_a1cI[sk:1] -> s_a2hh[fmv:1]) (CTyEqCan)
Sneaky unification:
  Unifies: a_a1el[tau:1] := b_a1cI[sk:1] -> s_a2hh[fmv:1]
  Coercion: a_a1el[tau:1] ~ (b_a1cI[sk:1] -> s_a2hh[fmv:1])
  Left Kind is: *
  Right Kind is: *
unifyTyVar a_a1el[tau:1] := b_a1cI[sk:1] -> s_a2hh[fmv:1]
writeMetaTyVar a_a1el[tau:1] :: * := b_a1cI[sk:1] -> s_a2hh[fmv:1]
Filling coercion hole co_a2hj := <b_a1cI[sk:1] -> s_a2hh[fmv:1]>_N
end stage interact with inerts }
Step 4[l:1,d:1] Solved by unification:
    [WD] hole{co_a2hj} {1}:: a_a1el[tau:1]
                             GHC.Prim.~# (b_a1cI[sk:1] -> s_a2hh[fmv:1])
End solver pipeline (discharged) }
----------------------------- 
Start solver pipeline {
  tclevel = 1
  work item = [WD] hole{co_a2hi} {0}:: G b_a1cI[sk:1]
                                       GHC.Prim.~# s_a2hh[fmv:1] (CFunEqCan)
  inerts = {Unsolved goals = 0}
           Inert fsks = []
  rest of worklist = WL {Non-eqs = [WD] $dIP_a2f1 {0}:: GHC.Stack.Types.HasCallStack (CNonCanonical)}
runStage canonicalization {
  workitem   =  [WD] hole{co_a2hi} {0}:: G b_a1cI[sk:1]
                                         GHC.Prim.~# s_a2hh[fmv:1] (CFunEqCan)
flatten_args { b_a1cI[sk:1]
Unfilled tyvar b_a1cI[sk:1]
flatten } b_a1cI[sk:1]
canCFunEqCan: refl
  G b_a1cI[sk:1]
  <G b_a1cI[sk:1]>_N
extendFlatCache
  G [b_a1cI[sk:1]]
  [WD]
  s_a2hh[fmv:1]
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] hole{co_a2hi} {0}:: G b_a1cI[sk:1]
                                         GHC.Prim.~# s_a2hh[fmv:1] (CFunEqCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [WD] hole{co_a2hi} {0}:: G b_a1cI[sk:1]
                                         GHC.Prim.~# s_a2hh[fmv:1] (CFunEqCan)
doTopReact
  [WD] hole{co_a2hi} {0}:: G b_a1cI[sk:1]
                           GHC.Prim.~# s_a2hh[fmv:1] (CFunEqCan)
matchFamTcM
  Matching: G b_a1cI[sk:1]
  Match failed
improveTopFunEqs
  G [b_a1cI[sk:1]] s_a2hh[fmv:1]
  []
end stage top-level reactions }
insertInertCan {
  Trying to insert new inert item: [WD] hole{co_a2hi} {0}:: G b_a1cI[sk:1]
                                                            GHC.Prim.~# s_a2hh[fmv:1] (CFunEqCan)
addInertCan }
Step 5[l:1,d:0] Kept as inert:
    [WD] hole{co_a2hi} {0}:: G b_a1cI[sk:1] GHC.Prim.~# s_a2hh[fmv:1]
End solver pipeline (kept as inert) }
  final_item = [WD] hole{co_a2hi} {0}:: G b_a1cI[sk:1]
                                        GHC.Prim.~# s_a2hh[fmv:1] (CFunEqCan)
----------------------------- 
Start solver pipeline {
  tclevel = 1
  work item = [WD] $dIP_a2f1 {0}:: GHC.Stack.Types.HasCallStack (CNonCanonical)
  inerts = {Type-function equalities = [WD] hole{co_a2hi} {0}:: G b_a1cI[sk:1]
                                                                GHC.Prim.~# s_a2hh[fmv:1] (CFunEqCan)
            Unsolved goals = 0}
           Inert fsks = []
  rest of worklist = WL {}
runStage canonicalization {
  workitem   =  [WD] $dIP_a2f1 {0}:: GHC.Stack.Types.HasCallStack (CNonCanonical)
canEvNC:cls GHC.Classes.IP ["callStack", GHC.Stack.Types.CallStack]
Emitting new wanted
  $dIP_a2hk :: GHC.Stack.Types.HasCallStack
  arising from a use of implicit parameter ‘?callStack’
  at GHCTest.hs:13:5-13
addTcEvBind
  a2f3
  [W] $dIP_a2f1
    = (GHC.Stack.Types.pushCallStack
         (GHC.CString.unpackCString# "undefined"#,
          GHC.Stack.Types.SrcLoc
            (GHC.CString.unpackCString# "main"#)
            (GHC.CString.unpackCString# "Main"#)
            (GHC.CString.unpackCString# "GHCTest.hs"#)
            (GHC.Types.I# 13#)
            (GHC.Types.I# 5#)
            (GHC.Types.I# 13#)
            (GHC.Types.I# 14#))
         ($dIP_a2hk
          `cast` (GHC.Classes.N:IP[0]
                      <"callStack">_N <GHC.Stack.Types.CallStack>_N
                  :: (?callStack::GHC.Stack.Types.CallStack)
                     ~R# GHC.Stack.Types.CallStack)))
      `cast` (Sym (GHC.Classes.N:IP[0]
                       <"callStack">_N <GHC.Stack.Types.CallStack>_N)
              :: GHC.Stack.Types.CallStack
                 ~R# (?callStack::GHC.Stack.Types.CallStack))
flatten_args {
  "callStack"
  GHC.Stack.Types.CallStack
flatten }
  "callStack"
  GHC.Stack.Types.CallStack
canClass
  [WD] $dIP_a2hk {0}:: GHC.Stack.Types.HasCallStack
  ?callStack::GHC.Stack.Types.CallStack
  ContinueWith [WD] $dIP_a2hk {0}:: ?callStack::GHC.Stack.Types.CallStack
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] $dIP_a2hk {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [WD] $dIP_a2hk {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)
doTopReact
  [WD] $dIP_a2hk {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)
matchClassInst pred = ?callStack::GHC.Stack.Types.CallStack {
matchInstEnv
  goal: GHC.Classes.IP ["callStack", GHC.Stack.Types.CallStack]
  matches: []
  unify: []
matchClass not matching ?callStack::GHC.Stack.Types.CallStack
} matchClassInst global result NoInstance
try_fundeps
  [WD] $dIP_a2hk {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)
end stage top-level reactions }
insertInertCan {
  Trying to insert new inert item: [WD] $dIP_a2hk {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)
addInertCan }
Step 6[l:1,d:0] Kept as inert:
    [WD] $dIP_a2hk {0}:: ?callStack::GHC.Stack.Types.CallStack
End solver pipeline (kept as inert) }
  final_item = [WD] $dIP_a2hk {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)
getUnsolvedInerts
   tv eqs = {}
  fun eqs = {[WD] hole{co_a2hi} {0}:: G b_a1cI[sk:1]
                                      GHC.Prim.~# s_a2hh[fmv:1] (CFunEqCan)}
  others = {[WD] $dIP_a2hk {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)}
  implics = {}
Unflattening
  {Funeqs = [WD] hole{co_a2hi} {0}:: G b_a1cI[sk:1]
                                     GHC.Prim.~# s_a2hh[fmv:1] (CFunEqCan)
   Tv eqs =}
Filling coercion hole co_a2hi := <G b_a1cI[sk:1]>_N
unflattenFmv s_a2hh[fmv:1] := G b_a1cI[sk:1]
writeMetaTyVar s_a2hh[fmv:1] :: * := G b_a1cI[sk:1]
Unflattening 1 {}
Unflattening 2 {}
Unflattening 3 {}
Unflattening done {}
solveSimpleWanteds end }
  iterations = 1
  residual = WC {wc_simple =
                   [WD] $dIP_a2hk {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)}
solveWanteds }
  final wc = WC {wc_simple =
                   [WD] $dIP_a2hk {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)}
  current evbinds  = {[W] $dIP_a2f1
                        = (GHC.Stack.Types.pushCallStack
                             (GHC.CString.unpackCString# "undefined"#,
                              GHC.Stack.Types.SrcLoc
                                (GHC.CString.unpackCString# "main"#)
                                (GHC.CString.unpackCString# "Main"#)
                                (GHC.CString.unpackCString# "GHCTest.hs"#)
                                (GHC.Types.I# 13#)
                                (GHC.Types.I# 5#)
                                (GHC.Types.I# 13#)
                                (GHC.Types.I# 14#))
                             ($dIP_a2hk
                              `cast` (GHC.Classes.N:IP[0]
                                          <"callStack">_N <GHC.Stack.Types.CallStack>_N
                                      :: (?callStack::GHC.Stack.Types.CallStack)
                                         ~R# GHC.Stack.Types.CallStack)))
                          `cast` (Sym (GHC.Classes.N:IP[0]
                                           <"callStack">_N <GHC.Stack.Types.CallStack>_N)
                                  :: GHC.Stack.Types.CallStack
                                     ~R# (?callStack::GHC.Stack.Types.CallStack))}
getNoGivenEqs
  No given equalities
  Skols: [b_a1cI[sk:1]]
  Inerts: {Unsolved goals = 0}
  Insols: {}
unflattenGivens []
zonkSimples done:
  {[WD] $dIP_a2hk {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)}
floatEqualities
  Skols = [b_a1cI[sk:1]]
  Extended skols = [a1cI :-> b_a1cI[sk:1], a2f1 :-> $dIP_a2f1]
  Simples = {[WD] $dIP_a2hk {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)}
  Eqs = {}
  Floated eqs = {}
solveImplication 2
  {}
  WC {wc_simple =
        [WD] $dIP_a2hk {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)}
setImplicationStatus(not-all-solved) {
  Implic {
    TcLevel = 1
    Skolems = b_a1cI[sk:1]
    No-eqs = True
    Status = Unsolved
    Given =
    Wanted =
      WC {wc_simple =
            [WD] $dIP_a2hk {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan)}
    Binds = EvBindsVar<a2f3>
    the type signature for:
      g :: forall b. b -> G b }
neededEvVars
  old_needs: []
  seeds3: [a2hi :-> co_a2hi, a2hj :-> co_a2hj, a2hk :-> $dIP_a2hk]
  ev_binds: [a2f1 :-> [W] $dIP_a2f1
                        = (GHC.Stack.Types.pushCallStack
                             (GHC.CString.unpackCString# "undefined"#,
                              GHC.Stack.Types.SrcLoc
                                (GHC.CString.unpackCString# "main"#)
                                (GHC.CString.unpackCString# "Main"#)
                                (GHC.CString.unpackCString# "GHCTest.hs"#)
                                (GHC.Types.I# 13#)
                                (GHC.Types.I# 5#)
                                (GHC.Types.I# 13#)
                                (GHC.Types.I# 14#))
                             ($dIP_a2hk
                              `cast` (GHC.Classes.N:IP[0]
                                          <"callStack">_N <GHC.Stack.Types.CallStack>_N
                                      :: (?callStack::GHC.Stack.Types.CallStack)
                                         ~R# GHC.Stack.Types.CallStack)))
                          `cast` (Sym (GHC.Classes.N:IP[0]
                                           <"callStack">_N <GHC.Stack.Types.CallStack>_N)
                                  :: GHC.Stack.Types.CallStack
                                     ~R# (?callStack::GHC.Stack.Types.CallStack))]
  live_ev_binds: [a2f1 :-> [W] $dIP_a2f1
                             = (GHC.Stack.Types.pushCallStack
                                  (GHC.CString.unpackCString# "undefined"#,
                                   GHC.Stack.Types.SrcLoc
                                     (GHC.CString.unpackCString# "main"#)
                                     (GHC.CString.unpackCString# "Main"#)
                                     (GHC.CString.unpackCString# "GHCTest.hs"#)
                                     (GHC.Types.I# 13#)
                                     (GHC.Types.I# 5#)
                                     (GHC.Types.I# 13#)
                                     (GHC.Types.I# 14#))
                                  ($dIP_a2hk
                                   `cast` (GHC.Classes.N:IP[0]
                                               <"callStack">_N <GHC.Stack.Types.CallStack>_N
                                           :: (?callStack::GHC.Stack.Types.CallStack)
                                              ~R# GHC.Stack.Types.CallStack)))
                               `cast` (Sym (GHC.Classes.N:IP[0]
                                                <"callStack">_N <GHC.Stack.Types.CallStack>_N)
                                       :: GHC.Stack.Types.CallStack
                                          ~R# (?callStack::GHC.Stack.Types.CallStack))]
setImplicationStatus(not-all-solved) }
  Implic {
    TcLevel = 1
    Skolems = b_a1cI[sk:1]
    No-eqs = True
    Status = Unsolved
    Given =
    Wanted =
      WC {wc_simple =
            [WD] $dIP_a2hk {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan(psc))}
    Binds = EvBindsVar<a2f3>
    the type signature for:
      g :: forall b. b -> G b }
solveImplication end }
  no_given_eqs = True
  floated_eqs = {}
  res_implic = Just Implic {
                      TcLevel = 1
                      Skolems = b_a1cI[sk:1]
                      No-eqs = True
                      Status = Unsolved
                      Given =
                      Wanted =
                        WC {wc_simple =
                              [WD] $dIP_a2hk {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan(psc))}
                      Binds = EvBindsVar<a2f3>
                      the type signature for:
                        g :: forall b. b -> G b }
  implication evbinds = {[W] $dIP_a2f1
                           = (GHC.Stack.Types.pushCallStack
                                (GHC.CString.unpackCString# "undefined"#,
                                 GHC.Stack.Types.SrcLoc
                                   (GHC.CString.unpackCString# "main"#)
                                   (GHC.CString.unpackCString# "Main"#)
                                   (GHC.CString.unpackCString# "GHCTest.hs"#)
                                   (GHC.Types.I# 13#)
                                   (GHC.Types.I# 5#)
                                   (GHC.Types.I# 13#)
                                   (GHC.Types.I# 14#))
                                ($dIP_a2hk
                                 `cast` (GHC.Classes.N:IP[0]
                                             <"callStack">_N <GHC.Stack.Types.CallStack>_N
                                         :: (?callStack::GHC.Stack.Types.CallStack)
                                            ~R# GHC.Stack.Types.CallStack)))
                             `cast` (Sym (GHC.Classes.N:IP[0]
                                              <"callStack">_N <GHC.Stack.Types.CallStack>_N)
                                     :: GHC.Stack.Types.CallStack
                                        ~R# (?callStack::GHC.Stack.Types.CallStack))}
  implication tvcs = [a2hi :-> co_a2hi, a2hj :-> co_a2hj]
solveImplication {
  Implic {
    TcLevel = 1
    Skolems = a_a2f4[sk:1]
    No-eqs = False
    Status = Unsolved
    Given = $d~_a2f6 :: a_a2f4[sk:1] ~ [F a_a2f4[sk:1]]
    Wanted =
      WC {wc_simple =
            [WD] hole{co_a2f8} {0}:: G b_a2f7[tau:1]
                                     GHC.Prim.~# Bool (CNonCanonical)}
    Binds = EvBindsVar<a2f9>
    the type signature for:
      asdf :: forall a. (a ~ [F a]) => a -> Bool }
  Inerts {Unsolved goals = 0}
         Inert fsks = []
solveSimpleGivens {
  [[G] $d~_a2f6 {0}:: a_a2f4[sk:1]
                      ~ [F a_a2f4[sk:1]] (CNonCanonical)]
----------------------------- 
Start solver pipeline {
  tclevel = 1
  work item = [G] $d~_a2f6 {0}:: a_a2f4[sk:1]
                                 ~ [F a_a2f4[sk:1]] (CNonCanonical)
  inerts = {Unsolved goals = 0}
           Inert fsks = []
  rest of worklist = WL {}
runStage canonicalization {
  workitem   =  [G] $d~_a2f6 {0}:: a_a2f4[sk:1]
                                   ~ [F a_a2f4[sk:1]] (CNonCanonical)
canEvNC:cls ~ [*, a_a2f4[sk:1], [F a_a2f4[sk:1]]]
addTcEvBind
  a2f9
  [G] $d~~_a2hl
    = Data.Type.Equality.$p1~
        @ * @ a_a2f4[sk:1] @ [F a_a2f4[sk:1]] $d~_a2f6
mk_superclasses_of
  ~~ [*, *, a_a2f4[sk:1], [F a_a2f4[sk:1]]]
  False
  [31e :-> ~]
addTcEvBind
  a2f9
  [G] co_a2hm
    = GHC.Types.heq_sel
        @ * @ * @ a_a2f4[sk:1] @ [F a_a2f4[sk:1]] $d~~_a2hl
Emitting fresh work
  [G] $d~~_a2hl {0}:: a_a2f4[sk:1] ~~ [F a_a2f4[sk:1]] (CDictCan)
  [G] co_a2hm {0}:: a_a2f4[sk:1]
                    GHC.Prim.~# [F a_a2f4[sk:1]] (CNonCanonical)
flatten_args {
  *
  a_a2f4[sk:1]
  [F a_a2f4[sk:1]]
Unfilled tyvar a_a2f4[sk:1]
matchFamTcM
  Matching: F a_a2f4[sk:1]
  Match failed
Unfilled tyvar a_a2f4[sk:1]
matchFamTcM
  Matching: F a_a2f4[sk:1]
  Match failed
addTcEvBind
  a2f9
  [G] co_a2ho = CO: <F a_a2f4[sk:1]>_N
extendFlatCache
  F [a_a2f4[sk:1]]
  [G]
  fsk_a2hn[fsk:1]
flatten/flat-cache miss
  F [a_a2f4[sk:1]]
  fsk_a2hn[fsk:1]
  [G] co_a2ho {0}:: F a_a2f4[sk:1] GHC.Prim.~# fsk_a2hn[fsk:1]
flatten }
  *
  a_a2f4[sk:1]
  [fsk_a2hn[fsk:1]]
canClass
  [G] $d~_a2f6 {0}:: a_a2f4[sk:1] ~ [F a_a2f4[sk:1]]
  a_a2f4[sk:1] ~ [fsk_a2hn[fsk:1]]
  ContinueWith [G] $d~_a2f6 {0}:: a_a2f4[sk:1] ~ [fsk_a2hn[fsk:1]]
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [G] $d~_a2f6 {0}:: a_a2f4[sk:1]
                                   ~ [fsk_a2hn[fsk:1]] (CDictCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [G] $d~_a2f6 {0}:: a_a2f4[sk:1]
                                   ~ [fsk_a2hn[fsk:1]] (CDictCan)
doTopReact
  [G] $d~_a2f6 {0}:: a_a2f4[sk:1] ~ [fsk_a2hn[fsk:1]] (CDictCan)
try_fundeps
  [G] $d~_a2f6 {0}:: a_a2f4[sk:1] ~ [fsk_a2hn[fsk:1]] (CDictCan)
end stage top-level reactions }
insertInertCan {
  Trying to insert new inert item: [G] $d~_a2f6 {0}:: a_a2f4[sk:1]
                                                      ~ [fsk_a2hn[fsk:1]] (CDictCan)
addInertCan }
Step 7[l:1,d:0] Kept as inert:
    [G] $d~_a2f6 {0}:: a_a2f4[sk:1] ~ [fsk_a2hn[fsk:1]]
End solver pipeline (kept as inert) }
  final_item = [G] $d~_a2f6 {0}:: a_a2f4[sk:1]
                                  ~ [fsk_a2hn[fsk:1]] (CDictCan)
----------------------------- 
Start solver pipeline {
  tclevel = 1
  work item = [G] $d~~_a2hl {0}:: a_a2f4[sk:1]
                                  ~~ [F a_a2f4[sk:1]] (CDictCan)
  inerts = {Dictionaries = [G] $d~_a2f6 {0}:: a_a2f4[sk:1]
                                              ~ [fsk_a2hn[fsk:1]] (CDictCan)
            Unsolved goals = 0}
           Inert fsks = [(fsk_a2hn[fsk:1], F a_a2f4[sk:1])]
  rest of worklist = WL {Eqs = [G] co_a2hm {0}:: a_a2f4[sk:1]
                                                 GHC.Prim.~# [F a_a2f4[sk:1]] (CNonCanonical)
                         Funeqs = [G] co_a2ho {0}:: F a_a2f4[sk:1]
                                                    GHC.Prim.~# fsk_a2hn[fsk:1] (CFunEqCan)}
runStage canonicalization {
  workitem   =  [G] $d~~_a2hl {0}:: a_a2f4[sk:1]
                                    ~~ [F a_a2f4[sk:1]] (CDictCan)
flatten_args {
  *
  *
  a_a2f4[sk:1]
  [F a_a2f4[sk:1]]
Unfilled tyvar a_a2f4[sk:1]
matchFamTcM
  Matching: F a_a2f4[sk:1]
  Match failed
Unfilled tyvar a_a2f4[sk:1]
flatten/flat-cache hit
  F [a_a2f4[sk:1]]
  fsk_a2hn[fsk:1]
Unfilled tyvar fsk_a2hn[fsk:1]
flatten }
  *
  *
  a_a2f4[sk:1]
  [fsk_a2hn[fsk:1]]
canClass
  [G] $d~~_a2hl {0}:: a_a2f4[sk:1] ~~ [F a_a2f4[sk:1]]
  a_a2f4[sk:1] ~~ [fsk_a2hn[fsk:1]]
  ContinueWith [G] $d~~_a2hl {0}:: a_a2f4[sk:1] ~~ [fsk_a2hn[fsk:1]]
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [G] $d~~_a2hl {0}:: a_a2f4[sk:1]
                                    ~~ [fsk_a2hn[fsk:1]] (CDictCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [G] $d~~_a2hl {0}:: a_a2f4[sk:1]
                                    ~~ [fsk_a2hn[fsk:1]] (CDictCan)
doTopReact
  [G] $d~~_a2hl {0}:: a_a2f4[sk:1] ~~ [fsk_a2hn[fsk:1]] (CDictCan)
try_fundeps
  [G] $d~~_a2hl {0}:: a_a2f4[sk:1] ~~ [fsk_a2hn[fsk:1]] (CDictCan)
end stage top-level reactions }
insertInertCan {
  Trying to insert new inert item: [G] $d~~_a2hl {0}:: a_a2f4[sk:1]
                                                       ~~ [fsk_a2hn[fsk:1]] (CDictCan)
addInertCan }
Step 8[l:1,d:0] Kept as inert:
    [G] $d~~_a2hl {0}:: a_a2f4[sk:1] ~~ [fsk_a2hn[fsk:1]]
End solver pipeline (kept as inert) }
  final_item = [G] $d~~_a2hl {0}:: a_a2f4[sk:1]
                                   ~~ [fsk_a2hn[fsk:1]] (CDictCan)
----------------------------- 
Start solver pipeline {
  tclevel = 1
  work item = [G] co_a2hm {0}:: a_a2f4[sk:1]
                                GHC.Prim.~# [F a_a2f4[sk:1]] (CNonCanonical)
  inerts = {Dictionaries = [G] $d~_a2f6 {0}:: a_a2f4[sk:1]
                                              ~ [fsk_a2hn[fsk:1]] (CDictCan)
                           [G] $d~~_a2hl {0}:: a_a2f4[sk:1] ~~ [fsk_a2hn[fsk:1]] (CDictCan)
            Unsolved goals = 0}
           Inert fsks = [(fsk_a2hn[fsk:1], F a_a2f4[sk:1])]
  rest of worklist = WL {Funeqs = [G] co_a2ho {0}:: F a_a2f4[sk:1]
                                                    GHC.Prim.~# fsk_a2hn[fsk:1] (CFunEqCan)}
runStage canonicalization {
  workitem   =  [G] co_a2hm {0}:: a_a2f4[sk:1]
                                  GHC.Prim.~# [F a_a2f4[sk:1]] (CNonCanonical)
canEvNC:eq
  a_a2f4[sk:1]
  [F a_a2f4[sk:1]]
can_eq_nc
  False
  [G] co_a2hm {0}:: a_a2f4[sk:1] GHC.Prim.~# [F a_a2f4[sk:1]]
  nominal equality
  a_a2f4[sk:1]
  a_a2f4[sk:1]
  [F a_a2f4[sk:1]]
  [F a_a2f4[sk:1]]
flatten { FM_FlattenAll a_a2f4[sk:1]
Unfilled tyvar a_a2f4[sk:1]
flatten } a_a2f4[sk:1]
flatten { FM_FlattenAll [F a_a2f4[sk:1]]
matchFamTcM
  Matching: F a_a2f4[sk:1]
  Match failed
Unfilled tyvar a_a2f4[sk:1]
flatten/flat-cache hit
  F [a_a2f4[sk:1]]
  fsk_a2hn[fsk:1]
Unfilled tyvar fsk_a2hn[fsk:1]
flatten } [fsk_a2hn[fsk:1]]
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [G] co_a2hm {0}:: a_a2f4[sk:1]
                                  GHC.Prim.~# [fsk_a2hn[fsk:1]] (CTyEqCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [G] co_a2hm {0}:: a_a2f4[sk:1]
                                  GHC.Prim.~# [fsk_a2hn[fsk:1]] (CTyEqCan)
doTopReact
  [G] co_a2hm {0}:: a_a2f4[sk:1]
                    GHC.Prim.~# [fsk_a2hn[fsk:1]] (CTyEqCan)
end stage top-level reactions }
insertInertCan {
  Trying to insert new inert item: [G] co_a2hm {0}:: a_a2f4[sk:1]
                                                     GHC.Prim.~# [fsk_a2hn[fsk:1]] (CTyEqCan)
Kick out, tv = a_a2f4[sk:1]
  n-kicked = 2
  kicked_out = WL {Eqs = [G] $d~_a2f6 {0}:: a_a2f4[sk:1]
                                            ~ [fsk_a2hn[fsk:1]] (CDictCan)
                         [G] $d~~_a2hl {0}:: a_a2f4[sk:1] ~~ [fsk_a2hn[fsk:1]] (CDictCan)}
  Residual inerts = {Unsolved goals = 0}
addInertCan }
Step 9[l:1,d:0] Kept as inert:
    [G] co_a2hm {0}:: a_a2f4[sk:1] GHC.Prim.~# [fsk_a2hn[fsk:1]]
End solver pipeline (kept as inert) }
  final_item = [G] co_a2hm {0}:: a_a2f4[sk:1]
                                 GHC.Prim.~# [fsk_a2hn[fsk:1]] (CTyEqCan)
----------------------------- 
Start solver pipeline {
  tclevel = 1
  work item = [G] $d~_a2f6 {0}:: a_a2f4[sk:1]
                                 ~ [fsk_a2hn[fsk:1]] (CDictCan)
  inerts = {Equalities: [G] co_a2hm {0}:: a_a2f4[sk:1]
                                          GHC.Prim.~# [fsk_a2hn[fsk:1]] (CTyEqCan)
            Unsolved goals = 0}
           Inert fsks = [(fsk_a2hn[fsk:1], F a_a2f4[sk:1])]
  rest of worklist = WL {Eqs = [G] $d~~_a2hl {0}:: a_a2f4[sk:1]
                                                   ~~ [fsk_a2hn[fsk:1]] (CDictCan)
                         Funeqs = [G] co_a2ho {0}:: F a_a2f4[sk:1]
                                                    GHC.Prim.~# fsk_a2hn[fsk:1] (CFunEqCan)}
runStage canonicalization {
  workitem   =  [G] $d~_a2f6 {0}:: a_a2f4[sk:1]
                                   ~ [fsk_a2hn[fsk:1]] (CDictCan)
flatten_args {
  *
  a_a2f4[sk:1]
  [fsk_a2hn[fsk:1]]
Unfilled tyvar a_a2f4[sk:1]
Following inert tyvar
  FM_FlattenAll a_a2f4[sk:1] = [fsk_a2hn[fsk:1]]
  [G] co_a2hm {0}:: a_a2f4[sk:1] GHC.Prim.~# [fsk_a2hn[fsk:1]]
Unfilled tyvar fsk_a2hn[fsk:1]
Unfilled tyvar fsk_a2hn[fsk:1]
flatten }
  *
  [fsk_a2hn[fsk:1]]
  [fsk_a2hn[fsk:1]]
addTcEvBind
  a2f9
  [G] $d~_a2hp
    = $d~_a2f6
      `cast` (Sub (Sym ((~) <*>_N (Sym co_a2hm) <[fsk_a2hn[fsk:1]]>_N)_N)
              :: (a_a2f4[sk:1] ~ [fsk_a2hn[fsk:1]])
                 ~R# ([F a_a2f4[sk:1]] ~ [fsk_a2hn[fsk:1]]))
canClass
  [G] $d~_a2f6 {0}:: a_a2f4[sk:1] ~ [fsk_a2hn[fsk:1]]
  [fsk_a2hn[fsk:1]] ~ [fsk_a2hn[fsk:1]]
  ContinueWith [G] $d~_a2hp {0}:: [fsk_a2hn[fsk:1]]
                                  ~ [fsk_a2hn[fsk:1]]
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [G] $d~_a2hp {0}:: [fsk_a2hn[fsk:1]]
                                   ~ [fsk_a2hn[fsk:1]] (CDictCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [G] $d~_a2hp {0}:: [fsk_a2hn[fsk:1]]
                                   ~ [fsk_a2hn[fsk:1]] (CDictCan)
doTopReact
  [G] $d~_a2hp {0}:: [fsk_a2hn[fsk:1]] ~ [fsk_a2hn[fsk:1]] (CDictCan)
try_fundeps
  [G] $d~_a2hp {0}:: [fsk_a2hn[fsk:1]] ~ [fsk_a2hn[fsk:1]] (CDictCan)
end stage top-level reactions }
insertInertCan {
  Trying to insert new inert item: [G] $d~_a2hp {0}:: [fsk_a2hn[fsk:1]]
                                                      ~ [fsk_a2hn[fsk:1]] (CDictCan)
addInertCan }
Step 10[l:1,d:0] Kept as inert:
    [G] $d~_a2hp {0}:: [fsk_a2hn[fsk:1]] ~ [fsk_a2hn[fsk:1]]
End solver pipeline (kept as inert) }
  final_item = [G] $d~_a2hp {0}:: [fsk_a2hn[fsk:1]]
                                  ~ [fsk_a2hn[fsk:1]] (CDictCan)
----------------------------- 
Start solver pipeline {
  tclevel = 1
  work item = [G] $d~~_a2hl {0}:: a_a2f4[sk:1]
                                  ~~ [fsk_a2hn[fsk:1]] (CDictCan)
  inerts = {Equalities: [G] co_a2hm {0}:: a_a2f4[sk:1]
                                          GHC.Prim.~# [fsk_a2hn[fsk:1]] (CTyEqCan)
            Dictionaries = [G] $d~_a2hp {0}:: [fsk_a2hn[fsk:1]]
                                              ~ [fsk_a2hn[fsk:1]] (CDictCan)
            Unsolved goals = 0}
           Inert fsks = [(fsk_a2hn[fsk:1], F a_a2f4[sk:1])]
  rest of worklist = WL {Funeqs = [G] co_a2ho {0}:: F a_a2f4[sk:1]
                                                    GHC.Prim.~# fsk_a2hn[fsk:1] (CFunEqCan)}
runStage canonicalization {
  workitem   =  [G] $d~~_a2hl {0}:: a_a2f4[sk:1]
                                    ~~ [fsk_a2hn[fsk:1]] (CDictCan)
flatten_args {
  *
  *
  a_a2f4[sk:1]
  [fsk_a2hn[fsk:1]]
Unfilled tyvar a_a2f4[sk:1]
Following inert tyvar
  FM_FlattenAll a_a2f4[sk:1] = [fsk_a2hn[fsk:1]]
  [G] co_a2hm {0}:: a_a2f4[sk:1] GHC.Prim.~# [fsk_a2hn[fsk:1]]
Unfilled tyvar fsk_a2hn[fsk:1]
Unfilled tyvar fsk_a2hn[fsk:1]
flatten }
  *
  *
  [fsk_a2hn[fsk:1]]
  [fsk_a2hn[fsk:1]]
addTcEvBind
  a2f9
  [G] $d~~_a2hq
    = $d~~_a2hl
      `cast` (Sub (Sym ((~~)
                          <*>_N <*>_N (Sym co_a2hm) <[fsk_a2hn[fsk:1]]>_N)_N)
              :: (a_a2f4[sk:1] ~~ [fsk_a2hn[fsk:1]])
                 ~R# ([F a_a2f4[sk:1]] ~~ [fsk_a2hn[fsk:1]]))
canClass
  [G] $d~~_a2hl {0}:: a_a2f4[sk:1] ~~ [fsk_a2hn[fsk:1]]
  [fsk_a2hn[fsk:1]] ~~ [fsk_a2hn[fsk:1]]
  ContinueWith [G] $d~~_a2hq {0}:: [fsk_a2hn[fsk:1]]
                                   ~~ [fsk_a2hn[fsk:1]]
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [G] $d~~_a2hq {0}:: [fsk_a2hn[fsk:1]]
                                    ~~ [fsk_a2hn[fsk:1]] (CDictCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [G] $d~~_a2hq {0}:: [fsk_a2hn[fsk:1]]
                                    ~~ [fsk_a2hn[fsk:1]] (CDictCan)
doTopReact
  [G] $d~~_a2hq {0}:: [fsk_a2hn[fsk:1]]
                      ~~ [fsk_a2hn[fsk:1]] (CDictCan)
try_fundeps
  [G] $d~~_a2hq {0}:: [fsk_a2hn[fsk:1]]
                      ~~ [fsk_a2hn[fsk:1]] (CDictCan)
end stage top-level reactions }
insertInertCan {
  Trying to insert new inert item: [G] $d~~_a2hq {0}:: [fsk_a2hn[fsk:1]]
                                                       ~~ [fsk_a2hn[fsk:1]] (CDictCan)
addInertCan }
Step 11[l:1,d:0] Kept as inert:
    [G] $d~~_a2hq {0}:: [fsk_a2hn[fsk:1]] ~~ [fsk_a2hn[fsk:1]]
End solver pipeline (kept as inert) }
  final_item = [G] $d~~_a2hq {0}:: [fsk_a2hn[fsk:1]]
                                   ~~ [fsk_a2hn[fsk:1]] (CDictCan)
----------------------------- 
Start solver pipeline {
  tclevel = 1
  work item = [G] co_a2ho {0}:: F a_a2f4[sk:1]
                                GHC.Prim.~# fsk_a2hn[fsk:1] (CFunEqCan)
  inerts = {Equalities: [G] co_a2hm {0}:: a_a2f4[sk:1]
                                          GHC.Prim.~# [fsk_a2hn[fsk:1]] (CTyEqCan)
            Dictionaries = [G] $d~_a2hp {0}:: [fsk_a2hn[fsk:1]]
                                              ~ [fsk_a2hn[fsk:1]] (CDictCan)
                           [G] $d~~_a2hq {0}:: [fsk_a2hn[fsk:1]]
                                               ~~ [fsk_a2hn[fsk:1]] (CDictCan)
            Unsolved goals = 0}
           Inert fsks = [(fsk_a2hn[fsk:1], F a_a2f4[sk:1])]
  rest of worklist = WL {}
runStage canonicalization {
  workitem   =  [G] co_a2ho {0}:: F a_a2f4[sk:1]
                                  GHC.Prim.~# fsk_a2hn[fsk:1] (CFunEqCan)
flatten_args { a_a2f4[sk:1]
Unfilled tyvar a_a2f4[sk:1]
Following inert tyvar
  FM_FlattenAll a_a2f4[sk:1] = [fsk_a2hn[fsk:1]]
  [G] co_a2hm {0}:: a_a2f4[sk:1] GHC.Prim.~# [fsk_a2hn[fsk:1]]
Unfilled tyvar fsk_a2hn[fsk:1]
flatten } [fsk_a2hn[fsk:1]]
canCFunEqCan: refl
  F [fsk_a2hn[fsk:1]]
  (F (Sym co_a2hm))_N
addTcEvBind
  a2f9
  [G] co_a2hr = CO: (F (Sym co_a2hm))_N ; co_a2ho
extendFlatCache
  F [[fsk_a2hn[fsk:1]]]
  [G]
  fsk_a2hn[fsk:1]
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [G] co_a2hr {1}:: F [fsk_a2hn[fsk:1]]
                                  GHC.Prim.~# fsk_a2hn[fsk:1] (CFunEqCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [G] co_a2hr {1}:: F [fsk_a2hn[fsk:1]]
                                  GHC.Prim.~# fsk_a2hn[fsk:1] (CFunEqCan)
doTopReact
  [G] co_a2hr {1}:: F [fsk_a2hn[fsk:1]]
                    GHC.Prim.~# fsk_a2hn[fsk:1] (CFunEqCan)
end stage top-level reactions }
insertInertCan {
  Trying to insert new inert item: [G] co_a2hr {1}:: F [fsk_a2hn[fsk:1]]
                                                     GHC.Prim.~# fsk_a2hn[fsk:1] (CFunEqCan)
addInertCan }
Step 12[l:1,d:1] Kept as inert:
    [G] co_a2hr {1}:: F [fsk_a2hn[fsk:1]] GHC.Prim.~# fsk_a2hn[fsk:1]
End solver pipeline (kept as inert) }
  final_item = [G] co_a2hr {1}:: F [fsk_a2hn[fsk:1]]
                                 GHC.Prim.~# fsk_a2hn[fsk:1] (CFunEqCan)
End solveSimpleGivens }
solveWanteds {
  WC {wc_simple =
        [WD] hole{co_a2f8} {0}:: G b_a2f7[tau:1]
                                 GHC.Prim.~# Bool (CNonCanonical)}
solveSimpleWanteds {
  {[WD] hole{co_a2f8} {0}:: G b_a2f7[tau:1]
                            GHC.Prim.~# Bool (CNonCanonical)}
----------------------------- 
Start solver pipeline {
  tclevel = 1
  work item = [WD] hole{co_a2f8} {0}:: G b_a2f7[tau:1]
                                       GHC.Prim.~# Bool (CNonCanonical)
  inerts = {Equalities: [G] co_a2hm {0}:: a_a2f4[sk:1]
                                          GHC.Prim.~# [fsk_a2hn[fsk:1]] (CTyEqCan)
            Type-function equalities = [G] co_a2hr {1}:: F [fsk_a2hn[fsk:1]]
                                                         GHC.Prim.~# fsk_a2hn[fsk:1] (CFunEqCan)
            Dictionaries = [G] $d~_a2hp {0}:: [fsk_a2hn[fsk:1]]
                                              ~ [fsk_a2hn[fsk:1]] (CDictCan)
                           [G] $d~~_a2hq {0}:: [fsk_a2hn[fsk:1]]
                                               ~~ [fsk_a2hn[fsk:1]] (CDictCan)
            Unsolved goals = 0}
           Inert fsks = [(fsk_a2hn[fsk:1], F a_a2f4[sk:1])]
  rest of worklist = WL {}
runStage canonicalization {
  workitem   =  [WD] hole{co_a2f8} {0}:: G b_a2f7[tau:1]
                                         GHC.Prim.~# Bool (CNonCanonical)
canEvNC:eq
  G b_a2f7[tau:1]
  Bool
can_eq_nc
  False
  [WD] hole{co_a2f8} {0}:: G b_a2f7[tau:1] GHC.Prim.~# Bool
  nominal equality
  G b_a2f7[tau:1]
  G b_a2f7[tau:1]
  Bool
  Bool
flatten { FM_FlattenAll G b_a2f7[tau:1]
matchFamTcM
  Matching: G b_a2f7[tau:1]
  Match failed
Following filled tyvar b_a2f7[tau:1] = a_a2f4[sk:1]
Unfilled tyvar a_a2f4[sk:1]
Following inert tyvar
  FM_FlattenAll a_a2f4[sk:1] = [fsk_a2hn[fsk:1]]
  [G] co_a2hm {0}:: a_a2f4[sk:1] GHC.Prim.~# [fsk_a2hn[fsk:1]]
Unfilled tyvar fsk_a2hn[fsk:1]
matchFamTcM
  Matching: G [fsk_a2hn[fsk:1]]
  Match succeeded:
    Rewrites to: Bool
    Coercion: Main.D:R:G[][0] <fsk_a2hn[fsk:1]>_N
Eager T.F. reduction success
  G
  [[fsk_a2hn[fsk:1]]]
  Bool
  Main.D:R:G[][0] <fsk_a2hn[fsk:1]>_N :: G [fsk_a2hn[fsk:1]] ~ Bool
extendFlatCache
  G [[fsk_a2hn[fsk:1]]]
  [WD]
  Bool
flatten } Bool
flatten { FM_FlattenAll Bool
flatten } Bool
New coercion hole: co_a2hs
Emitting new coercion hole {co_a2hs} :: Bool GHC.Prim.~# Bool
Filling coercion hole
  co_a2f8 := Sym (Sym (Main.D:R:G[][0]
                           <fsk_a2hn[fsk:1]>_N) ; (G (Sym co_a2hm))_N) ; {co_a2hs}
rewriteEqEvidence
  [WD] hole{co_a2f8} {0}:: G b_a2f7[tau:1] GHC.Prim.~# Bool
  Bool
  Bool
  Sym (Sym (Main.D:R:G[][0]
                <fsk_a2hn[fsk:1]>_N) ; (G (Sym co_a2hm))_N) ; {co_a2hs}
canTyConApp
  [WD] hole{co_a2hs} {1}:: Bool GHC.Prim.~# Bool
  nominal equality
  Bool
  []
  []
Filling coercion hole co_a2hs := <Bool>_N
end stage canonicalization }
Step 13[l:1,d:1] Decomposed TyConApp:
    [WD] hole{co_a2hs} {1}:: Bool GHC.Prim.~# Bool
End solver pipeline (discharged) }
getUnsolvedInerts
   tv eqs = {}
  fun eqs = {}
  others = {}
  implics = {}
Unflattening
  {Funeqs =
   Tv eqs =}
Unflattening 1 {}
Unflattening 2 {}
Unflattening 3 {}
Unflattening done {}
solveSimpleWanteds end }
  iterations = 1
  residual = WC {}
solveWanteds }
  final wc = WC {}
  current evbinds  = {[G] $d~~_a2hl
                        = Data.Type.Equality.$p1~
                            @ * @ a_a2f4[sk:1] @ [F a_a2f4[sk:1]] $d~_a2f6,
                      [G] co_a2hm
                        = GHC.Types.heq_sel
                            @ * @ * @ a_a2f4[sk:1] @ [F a_a2f4[sk:1]] $d~~_a2hl,
                      [G] co_a2ho = CO: <F a_a2f4[sk:1]>_N,
                      [G] $d~_a2hp
                        = $d~_a2f6
                          `cast` (Sub (Sym ((~) <*>_N (Sym co_a2hm) <[fsk_a2hn[fsk:1]]>_N)_N)
                                  :: (a_a2f4[sk:1] ~ [fsk_a2hn[fsk:1]])
                                     ~R# ([F a_a2f4[sk:1]] ~ [fsk_a2hn[fsk:1]])),
                      [G] $d~~_a2hq
                        = $d~~_a2hl
                          `cast` (Sub (Sym ((~~)
                                              <*>_N <*>_N (Sym co_a2hm) <[fsk_a2hn[fsk:1]]>_N)_N)
                                  :: (a_a2f4[sk:1] ~~ [fsk_a2hn[fsk:1]])
                                     ~R# ([F a_a2f4[sk:1]] ~~ [fsk_a2hn[fsk:1]])),
                      [G] co_a2hr = CO: (F (Sym co_a2hm))_N ; co_a2ho}
getNoGivenEqs
  No given equalities
  Skols: [a_a2f4[sk:1]]
  Inerts: {Equalities: [G] co_a2hm {0}:: a_a2f4[sk:1]
                                         GHC.Prim.~# [fsk_a2hn[fsk:1]] (CTyEqCan)
           Type-function equalities = [G] co_a2hr {1}:: F [fsk_a2hn[fsk:1]]
                                                        GHC.Prim.~# fsk_a2hn[fsk:1] (CFunEqCan)
           Dictionaries = [G] $d~_a2hp {0}:: [fsk_a2hn[fsk:1]]
                                             ~ [fsk_a2hn[fsk:1]] (CDictCan)
                          [G] $d~~_a2hq {0}:: [fsk_a2hn[fsk:1]]
                                              ~~ [fsk_a2hn[fsk:1]] (CDictCan)
           Unsolved goals = 0}
  Insols: {}
unflattenGivens [(fsk_a2hn[fsk:1], F a_a2f4[sk:1])]
writeMetaTyVar fsk_a2hn[fsk:1] :: * := F a_a2f4[sk:1]
zonkSimples done: {}
floatEqualities
  Skols = [a_a2f4[sk:1]]
  Extended skols = [a2f4 :-> a_a2f4[sk:1], a2f6 :-> $d~_a2f6,
                    a2hl :-> $d~~_a2hl, a2hm :-> co_a2hm, a2ho :-> co_a2ho,
                    a2hp :-> $d~_a2hp, a2hq :-> $d~~_a2hq, a2hr :-> co_a2hr]
  Simples = {}
  Eqs = {}
  Floated eqs = {}
solveImplication 2
  {}
  WC {}
setImplicationStatus(all-solved) {
  Implic {
    TcLevel = 1
    Skolems = a_a2f4[sk:1]
    No-eqs = True
    Status = Unsolved
    Given = $d~_a2f6 :: a_a2f4[sk:1] ~ [F a_a2f4[sk:1]]
    Wanted = WC {}
    Binds = EvBindsVar<a2f9>
    the type signature for:
      asdf :: forall a. (a ~ [F a]) => a -> Bool }
neededEvVars
  old_needs: []
  seeds3: [a2hm :-> co_a2hm, a2hs :-> co_a2hs]
  ev_binds: [a2hl :-> [G] $d~~_a2hl
                        = Data.Type.Equality.$p1~
                            @ * @ a_a2f4[sk:1] @ [F a_a2f4[sk:1]] $d~_a2f6,
             a2hm :-> [G] co_a2hm
                        = GHC.Types.heq_sel
                            @ * @ * @ a_a2f4[sk:1] @ [F a_a2f4[sk:1]] $d~~_a2hl,
             a2ho :-> [G] co_a2ho = CO: <F a_a2f4[sk:1]>_N,
             a2hp :-> [G] $d~_a2hp
                        = $d~_a2f6
                          `cast` (Sub (Sym ((~) <*>_N (Sym co_a2hm) <[fsk_a2hn[fsk:1]]>_N)_N)
                                  :: (a_a2f4[sk:1] ~ [fsk_a2hn[fsk:1]])
                                     ~R# ([F a_a2f4[sk:1]] ~ [fsk_a2hn[fsk:1]])),
             a2hq :-> [G] $d~~_a2hq
                        = $d~~_a2hl
                          `cast` (Sub (Sym ((~~)
                                              <*>_N <*>_N (Sym co_a2hm) <[fsk_a2hn[fsk:1]]>_N)_N)
                                  :: (a_a2f4[sk:1] ~~ [fsk_a2hn[fsk:1]])
                                     ~R# ([F a_a2f4[sk:1]] ~~ [fsk_a2hn[fsk:1]])),
             a2hr :-> [G] co_a2hr = CO: (F (Sym co_a2hm))_N ; co_a2ho]
  live_ev_binds: [a2hl :-> [G] $d~~_a2hl
                             = Data.Type.Equality.$p1~
                                 @ * @ a_a2f4[sk:1] @ [F a_a2f4[sk:1]] $d~_a2f6,
                  a2hm :-> [G] co_a2hm
                             = GHC.Types.heq_sel
                                 @ * @ * @ a_a2f4[sk:1] @ [F a_a2f4[sk:1]] $d~~_a2hl]
setImplicationStatus(all-solved) }
  discard: False
  new_implic: Implic {
                TcLevel = 1
                Skolems = a_a2f4[sk:1]
                No-eqs = True
                Status = Solved {Dead givens = []}
                Given = $d~_a2f6 :: a_a2f4[sk:1] ~ [F a_a2f4[sk:1]]
                Wanted = WC {}
                Binds = EvBindsVar<a2f9>
                the type signature for:
                  asdf :: forall a. (a ~ [F a]) => a -> Bool }
solveImplication end }
  no_given_eqs = True
  floated_eqs = {}
  res_implic = Just Implic {
                      TcLevel = 1
                      Skolems = a_a2f4[sk:1]
                      No-eqs = True
                      Status = Solved {Dead givens = []}
                      Given = $d~_a2f6 :: a_a2f4[sk:1] ~ [F a_a2f4[sk:1]]
                      Wanted = WC {}
                      Binds = EvBindsVar<a2f9>
                      the type signature for:
                        asdf :: forall a. (a ~ [F a]) => a -> Bool }
  implication evbinds = {[G] $d~~_a2hl
                           = Data.Type.Equality.$p1~
                               @ * @ a_a2f4[sk:1] @ [F a_a2f4[sk:1]] $d~_a2f6,
                         [G] co_a2hm
                           = GHC.Types.heq_sel
                               @ * @ * @ a_a2f4[sk:1] @ [F a_a2f4[sk:1]] $d~~_a2hl}
  implication tvcs = [a2hm :-> co_a2hm, a2hs :-> co_a2hs]
solveImplication {
  Implic {
    TcLevel = 1
    Skolems = a_a2fd[sk:1]
    No-eqs = False
    Status = Unsolved
    Given =
    Wanted =
      WC {wc_simple =
            [WD] $dIP_a2fu {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan(psc))}
    Binds = EvBindsVar<a2fk>
    the inferred type of main :: a_a2fd[tau:1] }
  Inerts {Unsolved goals = 0}
         Inert fsks = []
solveWanteds {
  WC {wc_simple =
        [WD] $dIP_a2fu {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan(psc))}
solveSimpleWanteds {
  {[WD] $dIP_a2fu {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan(psc))}
----------------------------- 
Start solver pipeline {
  tclevel = 1
  work item = [WD] $dIP_a2fu {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan(psc))
  inerts = {Unsolved goals = 0}
           Inert fsks = []
  rest of worklist = WL {}
runStage canonicalization {
  workitem   =  [WD] $dIP_a2fu {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan(psc))
flatten_args {
  "callStack"
  GHC.Stack.Types.CallStack
flatten }
  "callStack"
  GHC.Stack.Types.CallStack
canClass
  [WD] $dIP_a2fu {0}:: ?callStack::GHC.Stack.Types.CallStack
  ?callStack::GHC.Stack.Types.CallStack
  ContinueWith [WD] $dIP_a2fu {0}:: ?callStack::GHC.Stack.Types.CallStack
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [WD] $dIP_a2fu {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan(psc))
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [WD] $dIP_a2fu {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan(psc))
doTopReact
  [WD] $dIP_a2fu {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan(psc))
matchClassInst pred = ?callStack::GHC.Stack.Types.CallStack {
matchInstEnv
  goal: GHC.Classes.IP ["callStack", GHC.Stack.Types.CallStack]
  matches: []
  unify: []
matchClass not matching ?callStack::GHC.Stack.Types.CallStack
} matchClassInst global result NoInstance
try_fundeps
  [WD] $dIP_a2fu {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan(psc))
end stage top-level reactions }
insertInertCan {
  Trying to insert new inert item: [WD] $dIP_a2fu {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan(psc))
addInertCan }
Step 14[l:1,d:0] Kept as inert:
    [WD] $dIP_a2fu {0}:: ?callStack::GHC.Stack.Types.CallStack
End solver pipeline (kept as inert) }
  final_item = [WD] $dIP_a2fu {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan(psc))
getUnsolvedInerts
   tv eqs = {}
  fun eqs = {}
  others = {[WD] $dIP_a2fu {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan(psc))}
  implics = {}
Unflattening
  {Funeqs =
   Tv eqs =}
Unflattening 1 {}
Unflattening 2 {}
Unflattening 3 {}
Unflattening done {}
solveSimpleWanteds end }
  iterations = 1
  residual = WC {wc_simple =
                   [WD] $dIP_a2fu {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan(psc))}
solveWanteds }
  final wc = WC {wc_simple =
                   [WD] $dIP_a2fu {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan(psc))}
  current evbinds  = {[W] $dIP_a2ff
                        = (GHC.Stack.Types.pushCallStack
                             (GHC.CString.unpackCString# "undefined"#,
                              GHC.Stack.Types.SrcLoc
                                (GHC.CString.unpackCString# "main"#)
                                (GHC.CString.unpackCString# "Main"#)
                                (GHC.CString.unpackCString# "GHCTest.hs"#)
                                (GHC.Types.I# 4#)
                                (GHC.Types.I# 8#)
                                (GHC.Types.I# 4#)
                                (GHC.Types.I# 17#))
                             ($dIP_a2fu
                              `cast` (GHC.Classes.N:IP[0]
                                          <"callStack">_N <GHC.Stack.Types.CallStack>_N
                                      :: (?callStack::GHC.Stack.Types.CallStack)
                                         ~R# GHC.Stack.Types.CallStack)))
                          `cast` (Sym (GHC.Classes.N:IP[0]
                                           <"callStack">_N <GHC.Stack.Types.CallStack>_N)
                                  :: GHC.Stack.Types.CallStack
                                     ~R# (?callStack::GHC.Stack.Types.CallStack))}
getNoGivenEqs
  No given equalities
  Skols: [a_a2fd[sk:1]]
  Inerts: {Unsolved goals = 0}
  Insols: {}
unflattenGivens []
zonkSimples done:
  {[WD] $dIP_a2fu {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan(psc))}
floatEqualities
  Skols = [a_a2fd[sk:1]]
  Extended skols = [a2fd :-> a_a2fd[sk:1], a2ff :-> $dIP_a2ff]
  Simples = {[WD] $dIP_a2fu {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan(psc))}
  Eqs = {}
  Floated eqs = {}
solveImplication 2
  {}
  WC {wc_simple =
        [WD] $dIP_a2fu {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan(psc))}
setImplicationStatus(not-all-solved) {
  Implic {
    TcLevel = 1
    Skolems = a_a2fd[sk:1]
    No-eqs = True
    Status = Unsolved
    Given =
    Wanted =
      WC {wc_simple =
            [WD] $dIP_a2fu {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan(psc))}
    Binds = EvBindsVar<a2fk>
    the inferred type of main :: a_a2fd[tau:1] }
neededEvVars
  old_needs: []
  seeds3: [a2fu :-> $dIP_a2fu]
  ev_binds: [a2ff :-> [W] $dIP_a2ff
                        = (GHC.Stack.Types.pushCallStack
                             (GHC.CString.unpackCString# "undefined"#,
                              GHC.Stack.Types.SrcLoc
                                (GHC.CString.unpackCString# "main"#)
                                (GHC.CString.unpackCString# "Main"#)
                                (GHC.CString.unpackCString# "GHCTest.hs"#)
                                (GHC.Types.I# 4#)
                                (GHC.Types.I# 8#)
                                (GHC.Types.I# 4#)
                                (GHC.Types.I# 17#))
                             ($dIP_a2fu
                              `cast` (GHC.Classes.N:IP[0]
                                          <"callStack">_N <GHC.Stack.Types.CallStack>_N
                                      :: (?callStack::GHC.Stack.Types.CallStack)
                                         ~R# GHC.Stack.Types.CallStack)))
                          `cast` (Sym (GHC.Classes.N:IP[0]
                                           <"callStack">_N <GHC.Stack.Types.CallStack>_N)
                                  :: GHC.Stack.Types.CallStack
                                     ~R# (?callStack::GHC.Stack.Types.CallStack))]
  live_ev_binds: [a2ff :-> [W] $dIP_a2ff
                             = (GHC.Stack.Types.pushCallStack
                                  (GHC.CString.unpackCString# "undefined"#,
                                   GHC.Stack.Types.SrcLoc
                                     (GHC.CString.unpackCString# "main"#)
                                     (GHC.CString.unpackCString# "Main"#)
                                     (GHC.CString.unpackCString# "GHCTest.hs"#)
                                     (GHC.Types.I# 4#)
                                     (GHC.Types.I# 8#)
                                     (GHC.Types.I# 4#)
                                     (GHC.Types.I# 17#))
                                  ($dIP_a2fu
                                   `cast` (GHC.Classes.N:IP[0]
                                               <"callStack">_N <GHC.Stack.Types.CallStack>_N
                                           :: (?callStack::GHC.Stack.Types.CallStack)
                                              ~R# GHC.Stack.Types.CallStack)))
                               `cast` (Sym (GHC.Classes.N:IP[0]
                                                <"callStack">_N <GHC.Stack.Types.CallStack>_N)
                                       :: GHC.Stack.Types.CallStack
                                          ~R# (?callStack::GHC.Stack.Types.CallStack))]
setImplicationStatus(not-all-solved) }
  Implic {
    TcLevel = 1
    Skolems = a_a2fd[sk:1]
    No-eqs = True
    Status = Unsolved
    Given =
    Wanted =
      WC {wc_simple =
            [WD] $dIP_a2fu {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan(psc))}
    Binds = EvBindsVar<a2fk>
    the inferred type of main :: a_a2fd[tau:1] }
solveImplication end }
  no_given_eqs = True
  floated_eqs = {}
  res_implic = Just Implic {
                      TcLevel = 1
                      Skolems = a_a2fd[sk:1]
                      No-eqs = True
                      Status = Unsolved
                      Given =
                      Wanted =
                        WC {wc_simple =
                              [WD] $dIP_a2fu {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan(psc))}
                      Binds = EvBindsVar<a2fk>
                      the inferred type of main :: a_a2fd[tau:1] }
  implication evbinds = {[W] $dIP_a2ff
                           = (GHC.Stack.Types.pushCallStack
                                (GHC.CString.unpackCString# "undefined"#,
                                 GHC.Stack.Types.SrcLoc
                                   (GHC.CString.unpackCString# "main"#)
                                   (GHC.CString.unpackCString# "Main"#)
                                   (GHC.CString.unpackCString# "GHCTest.hs"#)
                                   (GHC.Types.I# 4#)
                                   (GHC.Types.I# 8#)
                                   (GHC.Types.I# 4#)
                                   (GHC.Types.I# 17#))
                                ($dIP_a2fu
                                 `cast` (GHC.Classes.N:IP[0]
                                             <"callStack">_N <GHC.Stack.Types.CallStack>_N
                                         :: (?callStack::GHC.Stack.Types.CallStack)
                                            ~R# GHC.Stack.Types.CallStack)))
                             `cast` (Sym (GHC.Classes.N:IP[0]
                                              <"callStack">_N <GHC.Stack.Types.CallStack>_N)
                                     :: GHC.Stack.Types.CallStack
                                        ~R# (?callStack::GHC.Stack.Types.CallStack))}
  implication tvcs = []
solveNestedImplications end }
  all floated_eqs = {}
  unsolved_implics = {Just Implic {
                             TcLevel = 1
                             Skolems = b_a1cI[sk:1]
                             No-eqs = True
                             Status = Unsolved
                             Given =
                             Wanted =
                               WC {wc_simple =
                                     [WD] $dIP_a2hk {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan(psc))}
                             Binds = EvBindsVar<a2f3>
                             the type signature for:
                               g :: forall b. b -> G b },
                      Just Implic {
                             TcLevel = 1
                             Skolems = a_a2f4[sk:1]
                             No-eqs = True
                             Status = Solved {Dead givens = []}
                             Given = $d~_a2f6 :: a_a2f4[sk:1] ~ [F a_a2f4[sk:1]]
                             Wanted = WC {}
                             Binds = EvBindsVar<a2f9>
                             the type signature for:
                               asdf :: forall a. (a ~ [F a]) => a -> Bool },
                      Just Implic {
                             TcLevel = 1
                             Skolems = a_a2fd[sk:1]
                             No-eqs = True
                             Status = Unsolved
                             Given =
                             Wanted =
                               WC {wc_simple =
                                     [WD] $dIP_a2fu {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan(psc))}
                             Binds = EvBindsVar<a2fk>
                             the inferred type of main :: a_a2fd[tau:1] }}
solveWanteds }
  final wc = WC {wc_impl =
                   Implic {
                     TcLevel = 1
                     Skolems = b_a1cI[sk:1]
                     No-eqs = True
                     Status = Unsolved
                     Given =
                     Wanted =
                       WC {wc_simple =
                             [WD] $dIP_a2hk {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan(psc))}
                     Binds = EvBindsVar<a2f3>
                     the type signature for:
                       g :: forall b. b -> G b }
                   Implic {
                     TcLevel = 1
                     Skolems = a_a2f4[sk:1]
                     No-eqs = True
                     Status = Solved {Dead givens = []}
                     Given = $d~_a2f6 :: a_a2f4[sk:1] ~ [F a_a2f4[sk:1]]
                     Wanted = WC {}
                     Binds = EvBindsVar<a2f9>
                     the type signature for:
                       asdf :: forall a. (a ~ [F a]) => a -> Bool }
                   Implic {
                     TcLevel = 1
                     Skolems = a_a2fd[sk:1]
                     No-eqs = True
                     Status = Unsolved
                     Given =
                     Wanted =
                       WC {wc_simple =
                             [WD] $dIP_a2fu {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan(psc))}
                     Binds = EvBindsVar<a2fk>
                     the inferred type of main :: a_a2fd[tau:1] }}
  current evbinds  = {}
zonkSimples done: {}
zonkSimples done:
  {[WD] $dIP_a2hk {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan(psc))}
zonkSimples done: {}
zonkSimples done:
  {[WD] $dIP_a2fu {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan(psc))}
applyDefaultingRules {
  wanteds = WC {wc_impl =
                  Implic {
                    TcLevel = 1
                    Skolems = b_a1cI[sk:1]
                    No-eqs = True
                    Status = Unsolved
                    Given =
                    Wanted =
                      WC {wc_simple =
                            [WD] $dIP_a2hk {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan(psc))}
                    Binds = EvBindsVar<a2f3>
                    the type signature for:
                      g :: forall b. b -> G b }
                  Implic {
                    TcLevel = 1
                    Skolems = a_a2f4[sk:1]
                    No-eqs = True
                    Status = Solved {Dead givens = []}
                    Given = $d~_a2f6 :: a_a2f4[sk:1] ~ [F a_a2f4[sk:1]]
                    Wanted = WC {}
                    Binds = EvBindsVar<a2f9>
                    the type signature for:
                      asdf :: forall a. (a ~ [F a]) => a -> Bool }
                  Implic {
                    TcLevel = 1
                    Skolems = a_a2fd[sk:1]
                    No-eqs = True
                    Status = Unsolved
                    Given =
                    Wanted =
                      WC {wc_simple =
                            [WD] $dIP_a2fu {0}:: ?callStack::GHC.Stack.Types.CallStack (CDictCan(psc))}
                    Binds = EvBindsVar<a2fk>
                    the inferred type of main :: a_a2fd[sk:1] }}
  groups  = []
  info    = ([Integer, Double], (False, False))
applyDefaultingRules } []
addTcEvBind
  a2f3
  [W] $dIP_a2hk
    = GHC.Stack.Types.emptyCallStack
      `cast` (Sym (GHC.Classes.N:IP[0]
                       <"callStack">_N <GHC.Stack.Types.CallStack>_N)
              :: GHC.Stack.Types.CallStack
                 ~R# (?callStack::GHC.Stack.Types.CallStack))
setImplicationStatus(all-solved) {
  Implic {
    TcLevel = 1
    Skolems = b_a1cI[sk:1]
    No-eqs = True
    Status = Unsolved
    Given =
    Wanted = WC {}
    Binds = EvBindsVar<a2f3>
    the type signature for:
      g :: forall b. b -> G b }
neededEvVars
  old_needs: [a2hi :-> co_a2hi, a2hj :-> co_a2hj, a2hk :-> $dIP_a2hk]
  seeds3: [a2hi :-> co_a2hi, a2hj :-> co_a2hj, a2hk :-> $dIP_a2hk]
  ev_binds: [a2f1 :-> [W] $dIP_a2f1
                        = (GHC.Stack.Types.pushCallStack
                             (GHC.CString.unpackCString# "undefined"#,
                              GHC.Stack.Types.SrcLoc
                                (GHC.CString.unpackCString# "main"#)
                                (GHC.CString.unpackCString# "Main"#)
                                (GHC.CString.unpackCString# "GHCTest.hs"#)
                                (GHC.Types.I# 13#)
                                (GHC.Types.I# 5#)
                                (GHC.Types.I# 13#)
                                (GHC.Types.I# 14#))
                             ($dIP_a2hk
                              `cast` (GHC.Classes.N:IP[0]
                                          <"callStack">_N <GHC.Stack.Types.CallStack>_N
                                      :: (?callStack::GHC.Stack.Types.CallStack)
                                         ~R# GHC.Stack.Types.CallStack)))
                          `cast` (Sym (GHC.Classes.N:IP[0]
                                           <"callStack">_N <GHC.Stack.Types.CallStack>_N)
                                  :: GHC.Stack.Types.CallStack
                                     ~R# (?callStack::GHC.Stack.Types.CallStack)),
             a2hk :-> [W] $dIP_a2hk
                        = GHC.Stack.Types.emptyCallStack
                          `cast` (Sym (GHC.Classes.N:IP[0]
                                           <"callStack">_N <GHC.Stack.Types.CallStack>_N)
                                  :: GHC.Stack.Types.CallStack
                                     ~R# (?callStack::GHC.Stack.Types.CallStack))]
  live_ev_binds: [a2f1 :-> [W] $dIP_a2f1
                             = (GHC.Stack.Types.pushCallStack
                                  (GHC.CString.unpackCString# "undefined"#,
                                   GHC.Stack.Types.SrcLoc
                                     (GHC.CString.unpackCString# "main"#)
                                     (GHC.CString.unpackCString# "Main"#)
                                     (GHC.CString.unpackCString# "GHCTest.hs"#)
                                     (GHC.Types.I# 13#)
                                     (GHC.Types.I# 5#)
                                     (GHC.Types.I# 13#)
                                     (GHC.Types.I# 14#))
                                  ($dIP_a2hk
                                   `cast` (GHC.Classes.N:IP[0]
                                               <"callStack">_N <GHC.Stack.Types.CallStack>_N
                                           :: (?callStack::GHC.Stack.Types.CallStack)
                                              ~R# GHC.Stack.Types.CallStack)))
                               `cast` (Sym (GHC.Classes.N:IP[0]
                                                <"callStack">_N <GHC.Stack.Types.CallStack>_N)
                                       :: GHC.Stack.Types.CallStack
                                          ~R# (?callStack::GHC.Stack.Types.CallStack)),
                  a2hk :-> [W] $dIP_a2hk
                             = GHC.Stack.Types.emptyCallStack
                               `cast` (Sym (GHC.Classes.N:IP[0]
                                                <"callStack">_N <GHC.Stack.Types.CallStack>_N)
                                       :: GHC.Stack.Types.CallStack
                                          ~R# (?callStack::GHC.Stack.Types.CallStack))]
setImplicationStatus(all-solved) }
  discard: False
  new_implic: Implic {
                TcLevel = 1
                Skolems = b_a1cI[sk:1]
                No-eqs = True
                Status = Solved {Dead givens = []}
                Given =
                Wanted = WC {}
                Binds = EvBindsVar<a2f3>
                the type signature for:
                  g :: forall b. b -> G b }
addTcEvBind
  a2fk
  [W] $dIP_a2fu
    = GHC.Stack.Types.emptyCallStack
      `cast` (Sym (GHC.Classes.N:IP[0]
                       <"callStack">_N <GHC.Stack.Types.CallStack>_N)
              :: GHC.Stack.Types.CallStack
                 ~R# (?callStack::GHC.Stack.Types.CallStack))
setImplicationStatus(all-solved) {
  Implic {
    TcLevel = 1
    Skolems = a_a2fd[sk:1]
    No-eqs = True
    Status = Unsolved
    Given =
    Wanted = WC {}
    Binds = EvBindsVar<a2fk>
    the inferred type of main :: a_a2fd[tau:1] }
neededEvVars
  old_needs: [a2fu :-> $dIP_a2fu]
  seeds3: [a2fu :-> $dIP_a2fu]
  ev_binds: [a2ff :-> [W] $dIP_a2ff
                        = (GHC.Stack.Types.pushCallStack
                             (GHC.CString.unpackCString# "undefined"#,
                              GHC.Stack.Types.SrcLoc
                                (GHC.CString.unpackCString# "main"#)
                                (GHC.CString.unpackCString# "Main"#)
                                (GHC.CString.unpackCString# "GHCTest.hs"#)
                                (GHC.Types.I# 4#)
                                (GHC.Types.I# 8#)
                                (GHC.Types.I# 4#)
                                (GHC.Types.I# 17#))
                             ($dIP_a2fu
                              `cast` (GHC.Classes.N:IP[0]
                                          <"callStack">_N <GHC.Stack.Types.CallStack>_N
                                      :: (?callStack::GHC.Stack.Types.CallStack)
                                         ~R# GHC.Stack.Types.CallStack)))
                          `cast` (Sym (GHC.Classes.N:IP[0]
                                           <"callStack">_N <GHC.Stack.Types.CallStack>_N)
                                  :: GHC.Stack.Types.CallStack
                                     ~R# (?callStack::GHC.Stack.Types.CallStack)),
             a2fu :-> [W] $dIP_a2fu
                        = GHC.Stack.Types.emptyCallStack
                          `cast` (Sym (GHC.Classes.N:IP[0]
                                           <"callStack">_N <GHC.Stack.Types.CallStack>_N)
                                  :: GHC.Stack.Types.CallStack
                                     ~R# (?callStack::GHC.Stack.Types.CallStack))]
  live_ev_binds: [a2ff :-> [W] $dIP_a2ff
                             = (GHC.Stack.Types.pushCallStack
                                  (GHC.CString.unpackCString# "undefined"#,
                                   GHC.Stack.Types.SrcLoc
                                     (GHC.CString.unpackCString# "main"#)
                                     (GHC.CString.unpackCString# "Main"#)
                                     (GHC.CString.unpackCString# "GHCTest.hs"#)
                                     (GHC.Types.I# 4#)
                                     (GHC.Types.I# 8#)
                                     (GHC.Types.I# 4#)
                                     (GHC.Types.I# 17#))
                                  ($dIP_a2fu
                                   `cast` (GHC.Classes.N:IP[0]
                                               <"callStack">_N <GHC.Stack.Types.CallStack>_N
                                           :: (?callStack::GHC.Stack.Types.CallStack)
                                              ~R# GHC.Stack.Types.CallStack)))
                               `cast` (Sym (GHC.Classes.N:IP[0]
                                                <"callStack">_N <GHC.Stack.Types.CallStack>_N)
                                       :: GHC.Stack.Types.CallStack
                                          ~R# (?callStack::GHC.Stack.Types.CallStack)),
                  a2fu :-> [W] $dIP_a2fu
                             = GHC.Stack.Types.emptyCallStack
                               `cast` (Sym (GHC.Classes.N:IP[0]
                                                <"callStack">_N <GHC.Stack.Types.CallStack>_N)
                                       :: GHC.Stack.Types.CallStack
                                          ~R# (?callStack::GHC.Stack.Types.CallStack))]
setImplicationStatus(all-solved) }
  discard: True
  new_implic: Implic {
                TcLevel = 1
                Skolems = a_a2fd[sk:1]
                No-eqs = True
                Status = Solved {Dead givens = []}
                Given =
                Wanted = WC {}
                Binds = EvBindsVar<a2fk>
                the inferred type of main :: a_a2fd[tau:1] }
Constraint solver steps = 14
unflattenGivens []
End simplifyTop }
reportUnsolved {
newTcEvBinds unique = a2ht
reportUnsolved warning/error settings:
  type errors: TypeError
  expr holes: HoleError
  type holes: HoleError
  scope holes: HoleError
reportUnsolved (before zonking and tidying)
  WC {wc_impl =
        Implic {
          TcLevel = 1
          Skolems = b_a1cI[sk:1]
          No-eqs = True
          Status = Solved {Dead givens = []}
          Given =
          Wanted = WC {}
          Binds = EvBindsVar<a2f3>
          the type signature for:
            g :: forall b. b -> G b }
        Implic {
          TcLevel = 1
          Skolems = a_a2f4[sk:1]
          No-eqs = True
          Status = Solved {Dead givens = []}
          Given = $d~_a2f6 :: a_a2f4[sk:1] ~ [F a_a2f4[sk:1]]
          Wanted = WC {}
          Binds = EvBindsVar<a2f9>
          the type signature for:
            asdf :: forall a. (a ~ [F a]) => a -> Bool }}
zonkSimples done: {}
zonkSimples done: {}
zonkSimples done: {}
reportUnsolved (after zonking):
  Free tyvars:
  Tidy env: ([], [])
  Wanted: WC {wc_impl =
                Implic {
                  TcLevel = 1
                  Skolems = b_a1cI[sk:1]
                  No-eqs = True
                  Status = Solved {Dead givens = []}
                  Given =
                  Wanted = WC {}
                  Binds = EvBindsVar<a2f3>
                  the type signature for:
                    g :: forall b. b -> G b }
                Implic {
                  TcLevel = 1
                  Skolems = a_a2f4[sk:1]
                  No-eqs = True
                  Status = Solved {Dead givens = []}
                  Given = $d~_a2f6 :: a_a2f4[sk:1] ~ [F a_a2f4[sk:1]]
                  Wanted = WC {}
                  Binds = EvBindsVar<a2f9>
                  the type signature for:
                    asdf :: forall a. (a ~ [F a]) => a -> Bool }}
reportWanteds
  Simples = {}
  Suppress = False
rw2 []
tryReporters {
  []
  []
tryReporters } []
tryReporters {
  []
  []
tryReporters } []
reportImplic
  Implic {
    TcLevel = 1
    Skolems = b_a1cI[sk:1]
    No-eqs = True
    Status = Solved {Dead givens = []}
    Given =
    Wanted = WC {}
    Binds = EvBindsVar<a2f3>
    the type signature for:
      g :: forall b. b -> G b }
reportWanteds
  Simples = {}
  Suppress = False
rw2 []
tryReporters {
  []
  []
tryReporters } []
tryReporters {
  []
  []
tryReporters } []
reportImplic
  Implic {
    TcLevel = 1
    Skolems = a_a2f4[sk:1]
    No-eqs = True
    Status = Solved {Dead givens = []}
    Given = $d~_a2f6 :: a_a2f4[sk:1] ~ [F a_a2f4[sk:1]]
    Wanted = WC {}
    Binds = EvBindsVar<a2f9>
    the type signature for:
      asdf :: forall a. (a ~ [F a]) => a -> Bool }
reportWanteds
  Simples = {}
  Suppress = False
rw2 []
tryReporters {
  []
  []
tryReporters } []
tryReporters {
  []
  []
tryReporters } []
reportUnsolved }
reportUnsolved (unsafe overlapping) {
reportUnsolved (unsafe overlapping) }
mkTypeableBinds []
Tc9
Tc10
writeMetaTyVar t_a2fX[tau:0] :: * := GHC.Types.Any
Tc11
newTcEvBinds unique = a2in
checkSatisfiability { {}
checkSatisfiability } {}
unflattenGivens []
newTcEvBinds unique = a2io
checkSatisfiability { {$d~_a2f6}
solveSimpleGivens {
  [[G] $d~_a2f6 {0}:: a_a2f4 ~ [Main.F a_a2f4] (CNonCanonical)]
----------------------------- 
Start solver pipeline {
  tclevel = 0
  work item = [G] $d~_a2f6 {0}:: a_a2f4
                                 ~ [Main.F a_a2f4] (CNonCanonical)
  inerts = {Unsolved goals = 0}
           Inert fsks = []
  rest of worklist = WL {}
runStage canonicalization {
  workitem   =  [G] $d~_a2f6 {0}:: a_a2f4
                                   ~ [Main.F a_a2f4] (CNonCanonical)
canEvNC:cls ~ [*, a_a2f4, [Main.F a_a2f4]]
addTcEvBind
  a2io
  [G] $d~~_a2ip
    = Data.Type.Equality.$p1~ @ * @ a_a2f4 @ [Main.F a_a2f4] $d~_a2f6
mk_superclasses_of
  ~~ [*, *, a_a2f4, [Main.F a_a2f4]]
  False
  [31e :-> ~]
addTcEvBind
  a2io
  [G] co_a2iq
    = GHC.Types.heq_sel @ * @ * @ a_a2f4 @ [Main.F a_a2f4] $d~~_a2ip
Emitting fresh work
  [G] $d~~_a2ip {0}:: a_a2f4 ~~ [Main.F a_a2f4] (CDictCan)
  [G] co_a2iq {0}:: a_a2f4
                    GHC.Prim.~# [Main.F a_a2f4] (CNonCanonical)
flatten_args {
  *
  a_a2f4
  [Main.F a_a2f4]
Unfilled tyvar a_a2f4
matchFamTcM
  Matching: Main.F a_a2f4
  Match failed
Unfilled tyvar a_a2f4
matchFamTcM
  Matching: Main.F a_a2f4
  Match failed
addTcEvBind
  a2io
  [G] co_a2is = CO: <Main.F a_a2f4>_N
extendFlatCache
  Main.F [a_a2f4]
  [G]
  fsk_a2ir[fsk:0]
flatten/flat-cache miss
  Main.F [a_a2f4]
  fsk_a2ir[fsk:0]
  [G] co_a2is {0}:: Main.F a_a2f4 GHC.Prim.~# fsk_a2ir[fsk:0]
flatten }
  *
  a_a2f4
  [fsk_a2ir[fsk:0]]
canClass
  [G] $d~_a2f6 {0}:: a_a2f4 ~ [Main.F a_a2f4]
  a_a2f4 ~ [fsk_a2ir[fsk:0]]
  ContinueWith [G] $d~_a2f6 {0}:: a_a2f4 ~ [fsk_a2ir[fsk:0]]
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [G] $d~_a2f6 {0}:: a_a2f4
                                   ~ [fsk_a2ir[fsk:0]] (CDictCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [G] $d~_a2f6 {0}:: a_a2f4
                                   ~ [fsk_a2ir[fsk:0]] (CDictCan)
doTopReact [G] $d~_a2f6 {0}:: a_a2f4 ~ [fsk_a2ir[fsk:0]] (CDictCan)
try_fundeps
  [G] $d~_a2f6 {0}:: a_a2f4 ~ [fsk_a2ir[fsk:0]] (CDictCan)
end stage top-level reactions }
insertInertCan {
  Trying to insert new inert item: [G] $d~_a2f6 {0}:: a_a2f4
                                                      ~ [fsk_a2ir[fsk:0]] (CDictCan)
addInertCan }
Step 1[l:0,d:0] Kept as inert:
    [G] $d~_a2f6 {0}:: a_a2f4 ~ [fsk_a2ir[fsk:0]]
End solver pipeline (kept as inert) }
  final_item = [G] $d~_a2f6 {0}:: a_a2f4
                                  ~ [fsk_a2ir[fsk:0]] (CDictCan)
----------------------------- 
Start solver pipeline {
  tclevel = 0
  work item = [G] $d~~_a2ip {0}:: a_a2f4
                                  ~~ [Main.F a_a2f4] (CDictCan)
  inerts = {Dictionaries = [G] $d~_a2f6 {0}:: a_a2f4
                                              ~ [fsk_a2ir[fsk:0]] (CDictCan)
            Unsolved goals = 0}
           Inert fsks = [(fsk_a2ir[fsk:0], Main.F a_a2f4)]
  rest of worklist = WL {Eqs = [G] co_a2iq {0}:: a_a2f4
                                                 GHC.Prim.~# [Main.F a_a2f4] (CNonCanonical)
                         Funeqs = [G] co_a2is {0}:: Main.F a_a2f4
                                                    GHC.Prim.~# fsk_a2ir[fsk:0] (CFunEqCan)}
runStage canonicalization {
  workitem   =  [G] $d~~_a2ip {0}:: a_a2f4
                                    ~~ [Main.F a_a2f4] (CDictCan)
flatten_args {
  *
  *
  a_a2f4
  [Main.F a_a2f4]
Unfilled tyvar a_a2f4
matchFamTcM
  Matching: Main.F a_a2f4
  Match failed
Unfilled tyvar a_a2f4
flatten/flat-cache hit
  Main.F [a_a2f4]
  fsk_a2ir[fsk:0]
Unfilled tyvar fsk_a2ir[fsk:0]
flatten }
  *
  *
  a_a2f4
  [fsk_a2ir[fsk:0]]
canClass
  [G] $d~~_a2ip {0}:: a_a2f4 ~~ [Main.F a_a2f4]
  a_a2f4 ~~ [fsk_a2ir[fsk:0]]
  ContinueWith [G] $d~~_a2ip {0}:: a_a2f4 ~~ [fsk_a2ir[fsk:0]]
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [G] $d~~_a2ip {0}:: a_a2f4
                                    ~~ [fsk_a2ir[fsk:0]] (CDictCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [G] $d~~_a2ip {0}:: a_a2f4
                                    ~~ [fsk_a2ir[fsk:0]] (CDictCan)
doTopReact
  [G] $d~~_a2ip {0}:: a_a2f4 ~~ [fsk_a2ir[fsk:0]] (CDictCan)
try_fundeps
  [G] $d~~_a2ip {0}:: a_a2f4 ~~ [fsk_a2ir[fsk:0]] (CDictCan)
end stage top-level reactions }
insertInertCan {
  Trying to insert new inert item: [G] $d~~_a2ip {0}:: a_a2f4
                                                       ~~ [fsk_a2ir[fsk:0]] (CDictCan)
addInertCan }
Step 2[l:0,d:0] Kept as inert:
    [G] $d~~_a2ip {0}:: a_a2f4 ~~ [fsk_a2ir[fsk:0]]
End solver pipeline (kept as inert) }
  final_item = [G] $d~~_a2ip {0}:: a_a2f4
                                   ~~ [fsk_a2ir[fsk:0]] (CDictCan)
----------------------------- 
Start solver pipeline {
  tclevel = 0
  work item = [G] co_a2iq {0}:: a_a2f4
                                GHC.Prim.~# [Main.F a_a2f4] (CNonCanonical)
  inerts = {Dictionaries = [G] $d~_a2f6 {0}:: a_a2f4
                                              ~ [fsk_a2ir[fsk:0]] (CDictCan)
                           [G] $d~~_a2ip {0}:: a_a2f4 ~~ [fsk_a2ir[fsk:0]] (CDictCan)
            Unsolved goals = 0}
           Inert fsks = [(fsk_a2ir[fsk:0], Main.F a_a2f4)]
  rest of worklist = WL {Funeqs = [G] co_a2is {0}:: Main.F a_a2f4
                                                    GHC.Prim.~# fsk_a2ir[fsk:0] (CFunEqCan)}
runStage canonicalization {
  workitem   =  [G] co_a2iq {0}:: a_a2f4
                                  GHC.Prim.~# [Main.F a_a2f4] (CNonCanonical)
canEvNC:eq
  a_a2f4
  [Main.F a_a2f4]
can_eq_nc
  False
  [G] co_a2iq {0}:: a_a2f4 GHC.Prim.~# [Main.F a_a2f4]
  nominal equality
  a_a2f4
  a_a2f4
  [Main.F a_a2f4]
  [Main.F a_a2f4]
flatten { FM_FlattenAll a_a2f4
Unfilled tyvar a_a2f4
flatten } a_a2f4
flatten { FM_FlattenAll [Main.F a_a2f4]
matchFamTcM
  Matching: Main.F a_a2f4
  Match failed
Unfilled tyvar a_a2f4
flatten/flat-cache hit
  Main.F [a_a2f4]
  fsk_a2ir[fsk:0]
Unfilled tyvar fsk_a2ir[fsk:0]
flatten } [fsk_a2ir[fsk:0]]
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [G] co_a2iq {0}:: a_a2f4
                                  GHC.Prim.~# [fsk_a2ir[fsk:0]] (CTyEqCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [G] co_a2iq {0}:: a_a2f4
                                  GHC.Prim.~# [fsk_a2ir[fsk:0]] (CTyEqCan)
doTopReact
  [G] co_a2iq {0}:: a_a2f4 GHC.Prim.~# [fsk_a2ir[fsk:0]] (CTyEqCan)
end stage top-level reactions }
insertInertCan {
  Trying to insert new inert item: [G] co_a2iq {0}:: a_a2f4
                                                     GHC.Prim.~# [fsk_a2ir[fsk:0]] (CTyEqCan)
Kick out, tv = a_a2f4
  n-kicked = 2
  kicked_out = WL {Eqs = [G] $d~_a2f6 {0}:: a_a2f4
                                            ~ [fsk_a2ir[fsk:0]] (CDictCan)
                         [G] $d~~_a2ip {0}:: a_a2f4 ~~ [fsk_a2ir[fsk:0]] (CDictCan)}
  Residual inerts = {Unsolved goals = 0}
addInertCan }
Step 3[l:0,d:0] Kept as inert:
    [G] co_a2iq {0}:: a_a2f4 GHC.Prim.~# [fsk_a2ir[fsk:0]]
End solver pipeline (kept as inert) }
  final_item = [G] co_a2iq {0}:: a_a2f4
                                 GHC.Prim.~# [fsk_a2ir[fsk:0]] (CTyEqCan)
----------------------------- 
Start solver pipeline {
  tclevel = 0
  work item = [G] $d~_a2f6 {0}:: a_a2f4
                                 ~ [fsk_a2ir[fsk:0]] (CDictCan)
  inerts = {Equalities: [G] co_a2iq {0}:: a_a2f4
                                          GHC.Prim.~# [fsk_a2ir[fsk:0]] (CTyEqCan)
            Unsolved goals = 0}
           Inert fsks = [(fsk_a2ir[fsk:0], Main.F a_a2f4)]
  rest of worklist = WL {Eqs = [G] $d~~_a2ip {0}:: a_a2f4
                                                   ~~ [fsk_a2ir[fsk:0]] (CDictCan)
                         Funeqs = [G] co_a2is {0}:: Main.F a_a2f4
                                                    GHC.Prim.~# fsk_a2ir[fsk:0] (CFunEqCan)}
runStage canonicalization {
  workitem   =  [G] $d~_a2f6 {0}:: a_a2f4
                                   ~ [fsk_a2ir[fsk:0]] (CDictCan)
flatten_args {
  *
  a_a2f4
  [fsk_a2ir[fsk:0]]
Unfilled tyvar a_a2f4
Following inert tyvar
  FM_FlattenAll a_a2f4 = [fsk_a2ir[fsk:0]]
  [G] co_a2iq {0}:: a_a2f4 GHC.Prim.~# [fsk_a2ir[fsk:0]]
Unfilled tyvar fsk_a2ir[fsk:0]
Unfilled tyvar fsk_a2ir[fsk:0]
flatten }
  *
  [fsk_a2ir[fsk:0]]
  [fsk_a2ir[fsk:0]]
addTcEvBind
  a2io
  [G] $d~_a2it
    = $d~_a2f6
      `cast` (Sub (Sym ((~) <*>_N (Sym co_a2iq) <[fsk_a2ir[fsk:0]]>_N)_N)
              :: (a_a2f4 ~ [fsk_a2ir[fsk:0]])
                 ~R# ([Main.F a_a2f4] ~ [fsk_a2ir[fsk:0]]))
canClass
  [G] $d~_a2f6 {0}:: a_a2f4 ~ [fsk_a2ir[fsk:0]]
  [fsk_a2ir[fsk:0]] ~ [fsk_a2ir[fsk:0]]
  ContinueWith [G] $d~_a2it {0}:: [fsk_a2ir[fsk:0]]
                                  ~ [fsk_a2ir[fsk:0]]
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [G] $d~_a2it {0}:: [fsk_a2ir[fsk:0]]
                                   ~ [fsk_a2ir[fsk:0]] (CDictCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [G] $d~_a2it {0}:: [fsk_a2ir[fsk:0]]
                                   ~ [fsk_a2ir[fsk:0]] (CDictCan)
doTopReact
  [G] $d~_a2it {0}:: [fsk_a2ir[fsk:0]] ~ [fsk_a2ir[fsk:0]] (CDictCan)
try_fundeps
  [G] $d~_a2it {0}:: [fsk_a2ir[fsk:0]] ~ [fsk_a2ir[fsk:0]] (CDictCan)
end stage top-level reactions }
insertInertCan {
  Trying to insert new inert item: [G] $d~_a2it {0}:: [fsk_a2ir[fsk:0]]
                                                      ~ [fsk_a2ir[fsk:0]] (CDictCan)
addInertCan }
Step 4[l:0,d:0] Kept as inert:
    [G] $d~_a2it {0}:: [fsk_a2ir[fsk:0]] ~ [fsk_a2ir[fsk:0]]
End solver pipeline (kept as inert) }
  final_item = [G] $d~_a2it {0}:: [fsk_a2ir[fsk:0]]
                                  ~ [fsk_a2ir[fsk:0]] (CDictCan)
----------------------------- 
Start solver pipeline {
  tclevel = 0
  work item = [G] $d~~_a2ip {0}:: a_a2f4
                                  ~~ [fsk_a2ir[fsk:0]] (CDictCan)
  inerts = {Equalities: [G] co_a2iq {0}:: a_a2f4
                                          GHC.Prim.~# [fsk_a2ir[fsk:0]] (CTyEqCan)
            Dictionaries = [G] $d~_a2it {0}:: [fsk_a2ir[fsk:0]]
                                              ~ [fsk_a2ir[fsk:0]] (CDictCan)
            Unsolved goals = 0}
           Inert fsks = [(fsk_a2ir[fsk:0], Main.F a_a2f4)]
  rest of worklist = WL {Funeqs = [G] co_a2is {0}:: Main.F a_a2f4
                                                    GHC.Prim.~# fsk_a2ir[fsk:0] (CFunEqCan)}
runStage canonicalization {
  workitem   =  [G] $d~~_a2ip {0}:: a_a2f4
                                    ~~ [fsk_a2ir[fsk:0]] (CDictCan)
flatten_args {
  *
  *
  a_a2f4
  [fsk_a2ir[fsk:0]]
Unfilled tyvar a_a2f4
Following inert tyvar
  FM_FlattenAll a_a2f4 = [fsk_a2ir[fsk:0]]
  [G] co_a2iq {0}:: a_a2f4 GHC.Prim.~# [fsk_a2ir[fsk:0]]
Unfilled tyvar fsk_a2ir[fsk:0]
Unfilled tyvar fsk_a2ir[fsk:0]
flatten }
  *
  *
  [fsk_a2ir[fsk:0]]
  [fsk_a2ir[fsk:0]]
addTcEvBind
  a2io
  [G] $d~~_a2iu
    = $d~~_a2ip
      `cast` (Sub (Sym ((~~)
                          <*>_N <*>_N (Sym co_a2iq) <[fsk_a2ir[fsk:0]]>_N)_N)
              :: (a_a2f4 ~~ [fsk_a2ir[fsk:0]])
                 ~R# ([Main.F a_a2f4] ~~ [fsk_a2ir[fsk:0]]))
canClass
  [G] $d~~_a2ip {0}:: a_a2f4 ~~ [fsk_a2ir[fsk:0]]
  [fsk_a2ir[fsk:0]] ~~ [fsk_a2ir[fsk:0]]
  ContinueWith [G] $d~~_a2iu {0}:: [fsk_a2ir[fsk:0]]
                                   ~~ [fsk_a2ir[fsk:0]]
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [G] $d~~_a2iu {0}:: [fsk_a2ir[fsk:0]]
                                    ~~ [fsk_a2ir[fsk:0]] (CDictCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [G] $d~~_a2iu {0}:: [fsk_a2ir[fsk:0]]
                                    ~~ [fsk_a2ir[fsk:0]] (CDictCan)
doTopReact
  [G] $d~~_a2iu {0}:: [fsk_a2ir[fsk:0]]
                      ~~ [fsk_a2ir[fsk:0]] (CDictCan)
try_fundeps
  [G] $d~~_a2iu {0}:: [fsk_a2ir[fsk:0]]
                      ~~ [fsk_a2ir[fsk:0]] (CDictCan)
end stage top-level reactions }
insertInertCan {
  Trying to insert new inert item: [G] $d~~_a2iu {0}:: [fsk_a2ir[fsk:0]]
                                                       ~~ [fsk_a2ir[fsk:0]] (CDictCan)
addInertCan }
Step 5[l:0,d:0] Kept as inert:
    [G] $d~~_a2iu {0}:: [fsk_a2ir[fsk:0]] ~~ [fsk_a2ir[fsk:0]]
End solver pipeline (kept as inert) }
  final_item = [G] $d~~_a2iu {0}:: [fsk_a2ir[fsk:0]]
                                   ~~ [fsk_a2ir[fsk:0]] (CDictCan)
----------------------------- 
Start solver pipeline {
  tclevel = 0
  work item = [G] co_a2is {0}:: Main.F a_a2f4
                                GHC.Prim.~# fsk_a2ir[fsk:0] (CFunEqCan)
  inerts = {Equalities: [G] co_a2iq {0}:: a_a2f4
                                          GHC.Prim.~# [fsk_a2ir[fsk:0]] (CTyEqCan)
            Dictionaries = [G] $d~_a2it {0}:: [fsk_a2ir[fsk:0]]
                                              ~ [fsk_a2ir[fsk:0]] (CDictCan)
                           [G] $d~~_a2iu {0}:: [fsk_a2ir[fsk:0]]
                                               ~~ [fsk_a2ir[fsk:0]] (CDictCan)
            Unsolved goals = 0}
           Inert fsks = [(fsk_a2ir[fsk:0], Main.F a_a2f4)]
  rest of worklist = WL {}
runStage canonicalization {
  workitem   =  [G] co_a2is {0}:: Main.F a_a2f4
                                  GHC.Prim.~# fsk_a2ir[fsk:0] (CFunEqCan)
flatten_args { a_a2f4
Unfilled tyvar a_a2f4
Following inert tyvar
  FM_FlattenAll a_a2f4 = [fsk_a2ir[fsk:0]]
  [G] co_a2iq {0}:: a_a2f4 GHC.Prim.~# [fsk_a2ir[fsk:0]]
Unfilled tyvar fsk_a2ir[fsk:0]
flatten } [fsk_a2ir[fsk:0]]
canCFunEqCan: refl
  Main.F [fsk_a2ir[fsk:0]]
  (Main.F (Sym co_a2iq))_N
addTcEvBind
  a2io
  [G] co_a2iv = CO: (Main.F (Sym co_a2iq))_N ; co_a2is
extendFlatCache
  Main.F [[fsk_a2ir[fsk:0]]]
  [G]
  fsk_a2ir[fsk:0]
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [G] co_a2iv {1}:: Main.F [fsk_a2ir[fsk:0]]
                                  GHC.Prim.~# fsk_a2ir[fsk:0] (CFunEqCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [G] co_a2iv {1}:: Main.F [fsk_a2ir[fsk:0]]
                                  GHC.Prim.~# fsk_a2ir[fsk:0] (CFunEqCan)
doTopReact
  [G] co_a2iv {1}:: Main.F [fsk_a2ir[fsk:0]]
                    GHC.Prim.~# fsk_a2ir[fsk:0] (CFunEqCan)
end stage top-level reactions }
insertInertCan {
  Trying to insert new inert item: [G] co_a2iv {1}:: Main.F
                                                       [fsk_a2ir[fsk:0]]
                                                     GHC.Prim.~# fsk_a2ir[fsk:0] (CFunEqCan)
addInertCan }
Step 6[l:0,d:1] Kept as inert:
    [G] co_a2iv {1}:: Main.F [fsk_a2ir[fsk:0]]
                      GHC.Prim.~# fsk_a2ir[fsk:0]
End solver pipeline (kept as inert) }
  final_item = [G] co_a2iv {1}:: Main.F [fsk_a2ir[fsk:0]]
                                 GHC.Prim.~# fsk_a2ir[fsk:0] (CFunEqCan)
End solveSimpleGivens }
checkSatisfiability } {}
Constraint solver steps = 6
unflattenGivens [(fsk_a2ir[fsk:0], Main.F a_a2f4)]
writeMetaTyVar fsk_a2ir[fsk:0] :: * := Main.F a_a2f4
newTcEvBinds unique = a2iw
checkSatisfiability { {}
checkSatisfiability } {}
unflattenGivens []
Linking GHCTest ...
